{"version":3,"sources":["noose.js"],"names":["factory","window","document","exports","module","define","amd","Noose","noop","_min","Math","min","_max","max","defaults","classes","noose","selected","compute","container","ctrl","enabled","mode","move","scroll","scrollEdge","scrollbar","select","shift","start","stop","style","border","zIndex","throttle","[object Object]","opts","self","this","HTMLElement","Object","assign","containers","Error","querySelectorAll","coors","pointer","createElement","position","classList","add","started","throttled","_onStart","e","sameContainer","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","pStart","pEnd","end","updateContainerPosition","updatePointerPosition","x","w","y","h","shiftKey","nTop","top","nBottom","bottom","midX","floor","midY","ctrlKey","lastSelection","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","_onEnd","removeChild","Array","prototype","forEach","call","addEventListener","removeEventListener","remove","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","endY","className","elements","offsetX","offsetY","include","topX","topY","bottomX","bottomY","idx","indexOf","push","version"],"mappings":"CAMC,SAAUA,EAASC,EAAQC,GACD,iBAAZC,QAEPC,OAAOD,QAAUH,EAAQC,EAAQC,GACR,mBAAXG,QAAyBA,OAAOC,IAE9CD,OAAO,IACIL,EAAQC,EAAQC,IAG3BD,EAAOM,MAAQP,EAAQC,EAAQC,GAVvC,EAYE,SAAUD,EAAQC,GAChB,aAEA,SAASM,KACT,MAAMC,EAAOC,KAAKC,IACZC,EAAOF,KAAKG,IAGZC,EAAW,CAEbC,QAAS,CACLC,MAAO,QACPC,SAAU,YAGdC,SAAS,EAETC,UAAW,OAEXC,MAAM,EAENC,SAAS,EAETC,KAAM,QAENC,KAAMf,EAENgB,OAAQ,GAERC,WAAY,GAEZC,UAAW,GAEXC,OAAQ,IAERC,OAAO,EAEPC,MAAOrB,EAEPsB,KAAMtB,EAENuB,MAAO,CACHC,OAAQ,kBACRC,OAAQ,KAGZC,SAAU,KA+Xd,OA5XA,MACIC,YAAYhB,EAAWiB,GACnB,MAAMC,EAAOC,KAYb,GAVyB,iBAAdnB,GAAuC,MAAbA,GAAuBA,aAAqBoB,cAC7EH,EAAOjB,EACPA,EAAY,MAEhBiB,EAAOC,EAAKD,KAAOI,OAAOC,OAAO,GAAI3B,EAAUsB,IAEtB,iBAAdjB,GAA0BA,aAAqBoB,eACtDH,EAAKjB,UAAYA,GAGjBiB,EAAKjB,qBAAqBoB,YAC1BF,EAAKK,WAAa,CAACN,EAAKjB,eACrB,CAAA,GAA8B,iBAAnBiB,EAAKjB,UAGnB,MAAM,IAAIwB,MAAM,4BAFhBN,EAAKK,WAAaxC,EAAS0C,iBAAiBR,EAAKjB,WAKrDkB,EAAKQ,MAAQ,CAETC,QAAS,GAET9B,MAAO,GAEPG,UAAW,IAGf,MAAMH,EAAQqB,EAAKrB,MAAQd,EAAS6C,cAAc,OAClD/B,EAAMe,MAAMiB,SAAW,WACvBhC,EAAMe,MAAME,OAASG,EAAKL,MAAME,OAChCjB,EAAMe,MAAMC,OAASI,EAAKL,MAAMC,OAC5BI,EAAKrB,QAAQC,OACbA,EAAMiC,UAAUC,IAAId,EAAKrB,QAAQC,OAErC,IAAImC,GAAU,EACVC,GAAY,EAmLhB,OAlLAf,EAAKgB,SAAW,SAAUC,GACtB,MAAMC,EAAgBD,EAAEE,gBAAkBnB,EAAKmB,cAC/C,GAAIpB,EAAKf,WACH8B,IAAYI,KACF,cAAXD,EAAEG,MAAoC,IAAZH,EAAEI,OAAc,CAC3CP,GAAU,EACV,MAAMQ,EAAUtB,EAAKmB,cAAgBF,EAAEE,cACjCI,EAASvB,EAAKQ,MAAM1B,UACpB0C,EAASxB,EAAKQ,MAAMC,QACpBgB,EAASzB,EAAKQ,MAAM7B,MAGpBe,EAAQ9B,EAAO8D,iBAAiBJ,GACf,WAAnB5B,EAAMiB,UACNgB,QAAQC,KAAK,iHAGb7B,EAAKZ,OAAS,GAAKY,EAAKX,WAAa,GACrCmC,EAAOM,SAA+B,SAApBnC,EAAMoC,WAA4C,WAApBpC,EAAMoC,YAA2BR,EAAQS,aAAeT,EAAQU,aAChHT,EAAOU,SAA+B,SAApBvC,EAAMwC,WAA4C,WAApBxC,EAAMwC,YAA2BZ,EAAQa,YAAcb,EAAQc,cAE/Gb,EAAOM,SAAU,EACjBN,EAAOU,SAAU,GAGrBV,EAAOc,WAAad,EAAOU,SAAWX,EAAQS,aAAeT,EAAQU,cAAgB,EACrFT,EAAOe,WAAaf,EAAOM,SAAWP,EAAQa,YAAcb,EAAQc,aAAe,EAGnF,MAAMG,EAASf,EAAOhC,MAChBgD,EAAOhB,EAAOiB,IAQpB,GALAjB,EAAOhC,MAAQ,KACfiC,EAAOjC,MAAQ,KAEfQ,EAAK0C,0BAA0BC,sBAAsB1B,GAEjDlB,EAAKV,YACHkC,EAAOM,SAAWL,EAAOiB,IAAIG,EAAKrB,EAAOqB,EAAIrB,EAAOsB,EAAI9C,EAAKV,WAC3DkC,EAAOU,SAAWT,EAAOiB,IAAIK,EAAKvB,EAAOuB,EAAIvB,EAAOwB,EAAIhD,EAAKV,WAIjE,OAHAyB,GAAU,EACVU,EAAOhC,MAAQ+C,OACff,EAAOiB,IAAMD,GAKjB,GAAIzC,EAAKR,OAAS2B,GAAiBD,EAAE+B,UAAYT,EAAQ,CACrD,MAAMU,EAAOxB,EAAOyB,IACdC,EAAU1B,EAAO2B,OACjBC,EAAOhF,KAAKiF,OAAOf,EAAOK,EAAIJ,EAAKI,GAAK,GACxCW,EAAOlF,KAAKiF,OAAOf,EAAOO,EAAIN,EAAKM,GAAK,GAE9CrB,EAAOjC,MAAQ,GACXgC,EAAOhC,MAAMoD,GAAKS,GAAQ7B,EAAOhC,MAAMsD,EAAIS,GAE3C/B,EAAOhC,MAAMoD,EAAIxE,EAAKmE,EAAOK,EAAGJ,EAAKI,GACrCpB,EAAOhC,MAAMsD,EAAIvE,EAAKgE,EAAOO,EAAGN,EAAKM,GACrCrB,EAAOjC,MAAMoD,EAAIK,EAAKL,EACtBnB,EAAOjC,MAAMsD,EAAIK,EAAQL,GAClBtB,EAAOhC,MAAMoD,EAAIS,GAAQ7B,EAAOhC,MAAMsD,GAAKS,GAElD/B,EAAOhC,MAAMoD,EAAIrE,EAAKgE,EAAOK,EAAGJ,EAAKI,GACrCpB,EAAOhC,MAAMsD,EAAIvE,EAAKgE,EAAOO,EAAGN,EAAKM,GACrCrB,EAAOjC,MAAQ2D,GACR3B,EAAOhC,MAAMoD,GAAKS,GAAQ7B,EAAOhC,MAAMsD,EAAIS,GAElD/B,EAAOhC,MAAMoD,EAAIrE,EAAKgE,EAAOK,EAAGJ,EAAKI,GACrCpB,EAAOhC,MAAMsD,EAAI1E,EAAKmE,EAAOO,EAAGN,EAAKM,GACrCrB,EAAOjC,MAAMoD,EAAIO,EAAQP,EACzBnB,EAAOjC,MAAMsD,EAAIG,EAAKH,GACftB,EAAOhC,MAAMoD,EAAIS,GAAQ7B,EAAOhC,MAAMsD,GAAKS,IAElD/B,EAAOhC,MAAMoD,EAAIxE,EAAKmE,EAAOK,EAAGJ,EAAKI,GACrCpB,EAAOhC,MAAMsD,EAAI1E,EAAKmE,EAAOO,EAAGN,EAAKM,GACrCrB,EAAOjC,MAAQyD,GAYvB,GARIlD,EAAKhB,MAAQmC,GAAiBD,EAAEuC,QAChCxD,EAAKyD,cAAgBzD,EAAKpB,UAAY,GAEtCoB,EAAKyD,cAAgB,GAGzB9E,EAAMe,MAAMgE,QAAU,QAE0B,IAA5C3D,EAAKP,MAAMmE,MAAM3D,EAAM,CAACiB,EAAGjB,EAAKQ,QAIhC,OAHAM,GAAU,EACVU,EAAOhC,MAAQ+C,OACff,EAAOiB,IAAMD,GAIjBlB,EAAQsC,YAAYjF,KAG5BqB,EAAK6D,QAAU,SAAU5C,GACrB,GAAIlB,EAAKf,SACD8B,GAAWG,EAAEE,gBAAkBnB,EAAKmB,cAAe,CACnDF,EAAE6C,YAAc7C,EAAE8C,iBACH,WAAX9C,EAAEG,MACFpB,EAAK2C,sBAAsB1B,GAE/BjB,EAAK0C,0BAA0BsB,sBAE/B,IAAIf,EAAOjD,EAAKQ,MAAM7B,MAAMuE,IACxBC,EAAUnD,EAAKQ,MAAM7B,MAAMyE,OAC/BzE,EAAMe,MAAMuE,KAAOhB,EAAKL,EACxBjE,EAAMe,MAAMwD,IAAMD,EAAKH,EACvBnE,EAAMe,MAAMwE,MAASf,EAAQP,EAAIK,EAAKL,EACtCjE,EAAMe,MAAMyE,OAAUhB,EAAQL,EAAIG,EAAKH,EACvCnE,EAAMe,MAAMgE,QAAU,QAGtB,IAAIpC,EAAUtB,EAAKmB,cACfI,EAASvB,EAAKQ,MAAM1B,UACpB0D,EAAOxC,EAAKQ,MAAMC,QAAQgC,IAC1BlB,EAAOU,SAAYO,EAAKM,EAAIvB,EAAOuB,EAAI/C,EAAKX,WAC5CkC,EAAQ8C,WAAarE,EAAKZ,OACrBoC,EAAOU,SAAWX,EAAQ8C,UAAY7C,EAAOc,YAAed,EAAOuB,EAAIvB,EAAOwB,EAAIP,EAAKM,EAAI/C,EAAKX,WACrGkC,EAAQ8C,WAAarE,EAAKZ,OACrBoC,EAAOM,SAAYW,EAAKI,EAAIrB,EAAOqB,EAAI7C,EAAKX,WACjDkC,EAAQ+C,YAActE,EAAKZ,OACtBoC,EAAOM,SAAWP,EAAQ+C,WAAa9C,EAAOe,YAAef,EAAOqB,EAAIrB,EAAOsB,EAAIL,EAAKI,EAAI7C,EAAKX,aACtGkC,EAAQ+C,YAActE,EAAKZ,QAE3BY,EAAKlB,UAEDkB,EAAKF,SAEAkB,IACDA,GAAY,EACZuD,YAAW,WACPvD,GAAaf,EAAKnB,WAAakB,EAAKb,KAAKyE,MAAM3D,EAAM,CAACiB,EAAGjB,EAAKQ,MAAOR,EAAKpB,WAC1EmC,GAAY,IACbhB,EAAKF,YAGZG,EAAKnB,UACLkB,EAAKb,KAAKyE,MAAM3D,EAAM,CAACiB,EAAGjB,EAAKQ,MAAOR,EAAKpB,eAM/DoB,EAAKuE,OAAS,SAAUtD,GAChBjB,EAAKD,KAAKf,SACV8B,IACY,YAAXG,EAAEG,MAAkC,IAAZH,EAAEI,SAC3BP,GAAU,EACNG,EAAEE,gBAAkBnB,EAAKmB,gBACzBnB,EAAK0C,0BAA0BC,sBAAsB1B,GAAG+C,sBACxDjD,GAAY,EACZhB,EAAKlB,SAAWmB,EAAKnB,SAAQ,GAC7ByF,YAAW,WACPvE,EAAKN,KAAKkE,MAAM3D,EAAM,CAACiB,EAAGjB,EAAKQ,MAAOR,EAAKpB,aAC5C,GACHoB,EAAKmB,cAAcqD,YAAY7F,MAK3C8F,MAAMC,UAAUC,QAAQC,KAAK5E,EAAKK,YAAY,SAAUvB,GAGpDA,EAAU+F,iBAAiB,YAAa7E,EAAKgB,UAC7ClC,EAAU+F,iBAAiB,aAAc7E,EAAKgB,UAAU,GACxDlC,EAAU+F,iBAAiB,YAAa7E,EAAK6D,SAC7C/E,EAAU+F,iBAAiB,YAAa7E,EAAK6D,SAAS,GACtD/E,EAAU+F,iBAAiB,SAAU7E,EAAK6D,SAC1C/E,EAAU+F,iBAAiB,UAAW7E,EAAKuE,QAC3CzF,EAAU+F,iBAAiB,WAAY7E,EAAKuE,QAAQ,GAEpDzF,EAAUH,MAAQqB,KAGfA,EAOXF,UACI,MAAME,EAAOC,KAeb,OAdAD,EAAKK,WAAWsE,SAAQ,SAAU7F,GAC9BA,EAAUgG,oBAAoB,YAAa9E,EAAKgB,UAChDlC,EAAUgG,oBAAoB,aAAc9E,EAAKgB,UACjDlC,EAAUgG,oBAAoB,YAAa9E,EAAK6D,SAChD/E,EAAUgG,oBAAoB,YAAa9E,EAAK6D,SAChD/E,EAAUgG,oBAAoB,SAAU9E,EAAK6D,SAC7C/E,EAAUgG,oBAAoB,UAAW9E,EAAKuE,QAC9CzF,EAAUgG,oBAAoB,WAAY9E,EAAKuE,eAExCzF,EAAUH,SAErBqB,EAAKrB,MAAMoG,SACX/E,EAAKrB,MAAQ,KAENqB,EAOXF,0BACI,MAAMyB,EAAStB,KAAKO,MAAM1B,UACpBkG,EAAO/E,KAAKkB,cAAc8D,wBAOhC,OALA1D,EAAOqB,EAAIoC,EAAKf,KAAOrG,EAAOsH,YAC9B3D,EAAOuB,EAAIkC,EAAK9B,IAAMtF,EAAOuH,YAC7B5D,EAAOsB,EAAImC,EAAKd,MAChB3C,EAAOwB,EAAIiC,EAAKb,OAETlE,KAOXH,sBAAsBmB,GAClB,MAAMmE,EAAOnE,GAAKA,EAAEoE,SAAWpE,EAAEoE,QAAQ,IAAMpE,EACzCO,EAASvB,KAAKO,MAAMC,QAgB1B,OAdI2E,GAA8B,iBAAfA,EAAKE,QAIpB9D,EAAOiB,IAAM,CACTG,EAAGwC,EAAKE,MACRxC,EAAGsC,EAAKG,OAGP/D,EAAOhC,QACRgC,EAAOhC,MAAQgC,EAAOiB,MAIvBxC,KAOXH,sBACI,MAAMwB,EAAUrB,KAAKkB,cACfqB,EAAOvC,KAAKO,MAAMC,QAAQgC,IAC1BlB,EAAStB,KAAKO,MAAM1B,UACpB2C,EAASxB,KAAKO,MAAM7B,MAIpB6G,EAAOjH,EAAKiE,EAAKI,EAAIrB,EAAOqB,EAAItB,EAAQ+C,WAAY,GACpDoB,EAAOlH,EAAKiE,EAAKM,EAAIvB,EAAOuB,EAAIxB,EAAQ8C,UAAW,GAqBzD,OAnBK3C,EAAOjC,QAERiC,EAAOjC,MAAQ,CACXoD,EAAG4C,EACH1C,EAAG2C,IAMXhE,EAAOyB,IAAM,CACTN,EAAGxE,EAAKqD,EAAOjC,MAAMoD,EAAG4C,GACxB1C,EAAG1E,EAAKqD,EAAOjC,MAAMsD,EAAG2C,IAE5BhE,EAAO2B,OAAS,CACZR,EAAGxE,EAAKG,EAAKkD,EAAOjC,MAAMoD,EAAG4C,GAAOlE,EAAQa,aAC5CW,EAAG1E,EAAKG,EAAKkD,EAAOjC,MAAMsD,EAAG2C,GAAOnE,EAAQS,eAGzC9B,KAOXH,UACI,MAAME,EAAOC,KAEb,GAAID,EAAKD,KAAKT,OAAQ,CAClB,MAAMoG,EAAY1F,EAAKD,KAAKrB,QAAQE,SAC9BE,EAAYkB,EAAKmB,cACjBwE,EAAW7G,EAAUyB,iBAAiBP,EAAKD,KAAKT,QAChD2D,EAAOjD,EAAKQ,MAAM7B,MAAMuE,IACxBC,EAAUnD,EAAKQ,MAAM7B,MAAMyE,OAC3BwC,EAAU5F,EAAKQ,MAAM1B,UAAU8D,EAC/BiD,EAAU7F,EAAKQ,MAAM1B,UAAUgE,EAErC9C,EAAKpB,SAAW,GAEhB6F,MAAMC,UAAUC,QAAQC,KAAKe,GAAU,SAAUrE,GAC7C,GAAIA,IAAYtB,EAAKrB,MAAO,OAE5B,IAAImH,EAEJ,MAAMd,EAAO1D,EAAQ2D,wBACfc,EAAOf,EAAKf,KAAOrG,EAAOsH,YAAcU,EAAU9G,EAAUuF,WAC5D2B,EAAOhB,EAAK9B,IAAMtF,EAAOuH,YAAcU,EAAU/G,EAAUsF,UAC3D6B,EAAUjB,EAAKd,MAAQ6B,EACvBG,EAAUlB,EAAKb,OAAS6B,EAI1BF,EAFmB,QAAnB9F,EAAKD,KAAKd,KAEAgE,EAAKL,GAAKmD,GAAQ9C,EAAKH,GAAKkD,GAAQ7C,EAAQP,GAAKqD,GAAW9C,EAAQL,GAAKoD,IAGvEjD,EAAKL,EAAIqD,GAAWhD,EAAKH,EAAIoD,GAAW/C,EAAQP,EAAImD,GAAQ5C,EAAQL,EAAIkD,GAGxF,MAAMG,EAAMnG,EAAKyD,cAAc2C,QAAQ9E,GAEnCwE,IAAoB,IAATK,IAAeL,IAAoB,IAATK,GACrCT,GAAapE,EAAQV,UAAUC,IAAI6E,GACnC1F,EAAKpB,SAASyH,KAAK/E,IAEnBoE,GAAapE,EAAQV,UAAUmE,OAAOW,MAKlD,OAAO1F,EAKXsG,qBACI,MAAO,YAKhB1I,OAAQC","file":"noose.js","sourcesContent":["/**\n * Noose\n * \n * version: 1.0.0\n */\n\n(function (factory, window, document) {\n    if (typeof exports === 'object') {\n        // CommonJS\n        module.exports = factory(window, document);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(() => {\n            return factory(window, document)\n        });\n    } else {\n        window.Noose = factory(window, document);\n    }\n}(function (window, document) {\n    'use strict';\n\n    function noop() {}\n    const _min = Math.min;\n    const _max = Math.max;\n\n    // Default options\n    const defaults = {\n        // Classes for styling\n        classes: {\n            noose: 'noose',\n            selected: 'selected'\n        },\n        // Enable/disable computing of selected elements\n        compute: true,\n        // Containing element for the noose\n        container: 'body',\n        // Enable/disable support for ctrl key\n        ctrl: true,\n        // Whether the noose is enabled\n        enabled: true,\n        // The selection mode, part or whole\n        mode: 'touch',\n        // On noose move\n        move: noop,\n        // The amount of pixels to scroll\n        scroll: 10,\n        // The edge offset when scrolling should happen\n        scrollEdge: 10,\n        // The scrollbar size\n        scrollbar: 17,\n        // Elements to select\n        select: '*',\n        // Enabled/disable support for shift key\n        shift: true,\n        // On noose-ing start handler\n        start: noop,\n        // On noose-ing stop handler\n        stop: noop,\n        // Styles for the noose\n        style: {\n            border: '1px dotted #000',\n            zIndex: 1000\n        },\n        // Throttle calls to compute selection\n        throttle: 200\n    };\n\n    class Noose {\n        constructor(container, opts) {\n            const self = this;\n            // Parse arguments\n            if (typeof container === 'object' && container != null && !(container instanceof HTMLElement)) {\n                opts = container;\n                container = null;\n            }\n            opts = self.opts = Object.assign({}, defaults, opts);\n            // Container must be positioned (anything but static)\n            if (typeof container === 'string' || container instanceof HTMLElement) {\n                opts.container = container;\n            }\n            // Get containers\n            if (opts.container instanceof HTMLElement) {\n                self.containers = [opts.container];\n            } else if (typeof opts.container === 'string') {\n                self.containers = document.querySelectorAll(opts.container);\n            } else {\n                throw new Error('Invalid container option');\n            }\n            // Setup states\n            self.coors = {\n                // Relative to document top left origin\n                pointer: {},\n                // Relative to container\n                noose: {},\n                // Relative to document top left origin\n                container: {}\n            };\n            // Create noose\n            const noose = self.noose = document.createElement('div');\n            noose.style.position = 'absolute';\n            noose.style.zIndex = opts.style.zIndex;\n            noose.style.border = opts.style.border;\n            if (opts.classes.noose) {\n                noose.classList.add(opts.classes.noose);\n            }\n            let started = false; // Flag for noose-ing started\n            let throttled = false;\n            self._onStart = function (e) {\n                const sameContainer = e.currentTarget === self.currentTarget;\n                if (opts.enabled &&\n                    (!started || !sameContainer) &&\n                    (e.type !== 'mousedown' || e.which === 1)) {\n                    started = true;\n                    const element = self.currentTarget = e.currentTarget;\n                    const cCoors = self.coors.container;\n                    const pCoors = self.coors.pointer;\n                    const nCoors = self.coors.noose;\n\n                    // Initialize container values\n                    const style = window.getComputedStyle(element);\n                    if (style.position === 'static') {\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n                    }\n                    // Does the container have scrollbars\n                    if (opts.scroll > 0 && opts.scrollEdge > 0) {\n                        cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\n                        cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\n                    } else {\n                        cCoors.scrollX = false;\n                        cCoors.scrollY = false;\n                    }\n                    // Set the max allowed scroll amount\n                    cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\n                    cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0;\n\n                    // Get previous start coors in case we need to restore them\n                    const pStart = pCoors.start;\n                    const pEnd = pCoors.end;\n\n                    // Reset start positions\n                    pCoors.start = null;\n                    nCoors.start = null;\n\n                    self.updateContainerPosition().updatePointerPosition(e);\n                    // If the scrollbar was click then don't start\n                    if (opts.scrollbar &&\n                        ((cCoors.scrollX && pCoors.end.x > (cCoors.x + cCoors.w - opts.scrollbar) ||\n                            cCoors.scrollY && pCoors.end.y > (cCoors.y + cCoors.h - opts.scrollbar)))) {\n                        started = false;\n                        pCoors.start = pStart;\n                        pCoors.end = pEnd;\n                        return;\n                    }\n\n                    // Shift key is pressed, continue noose from previous opposing corner\n                    if (opts.shift && sameContainer && e.shiftKey && pStart) {\n                        const nTop = nCoors.top;\n                        const nBottom = nCoors.bottom;\n                        const midX = Math.floor((pStart.x + pEnd.x) / 2);\n                        const midY = Math.floor((pStart.y + pEnd.y) / 2);\n\n                        nCoors.start = {};\n                        if (pCoors.start.x >= midX && pCoors.start.y < midY) {\n                            // 1st quadrant\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\n                            nCoors.start.x = nTop.x;\n                            nCoors.start.y = nBottom.y;\n                        } else if (pCoors.start.x < midX && pCoors.start.y <= midY) {\n                            // 2nd quadrant\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\n                            nCoors.start = nBottom;\n                        } else if (pCoors.start.x <= midX && pCoors.start.y > midY) {\n                            // 3rd quadrant\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\n                            nCoors.start.x = nBottom.x;\n                            nCoors.start.y = nTop.y;\n                        } else if (pCoors.start.x > midX && pCoors.start.y >= midY) {\n                            // 4th quadrant\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\n                            nCoors.start = nTop;\n                        }\n                    }\n\n                    if (opts.ctrl && sameContainer && e.ctrlKey) {\n                        self.lastSelection = self.selected || [];\n                    } else {\n                        self.lastSelection = [];\n                    }\n\n                    noose.style.display = 'none';\n\n                    if (opts.start.apply(self, [e, self.coors]) === false) {\n                        started = false;\n                        pCoors.start = pStart;\n                        pCoors.end = pEnd;\n                        return;\n                    }\n\n                    element.appendChild(noose);\n                }\n            };\n            self._onMove = function (e) {\n                if (opts.enabled) {\n                    if (started && e.currentTarget === self.currentTarget) {\n                        e.cancelable && e.preventDefault();\n                        if (e.type !== 'scroll') {\n                            self.updatePointerPosition(e);\n                        }\n                        self.updateContainerPosition().updateNoosePosition();\n                        // Draw noose\n                        let nTop = self.coors.noose.top;\n                        let nBottom = self.coors.noose.bottom;\n                        noose.style.left = nTop.x;\n                        noose.style.top = nTop.y;\n                        noose.style.width = (nBottom.x - nTop.x);\n                        noose.style.height = (nBottom.y - nTop.y);\n                        noose.style.display = 'block';\n\n                        // Scroll container\n                        let element = self.currentTarget;\n                        let cCoors = self.coors.container;\n                        let pEnd = self.coors.pointer.end;\n                        if (cCoors.scrollY && (pEnd.y - cCoors.y < opts.scrollEdge))\n                            element.scrollTop -= opts.scroll;\n                        else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && (cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge))\n                            element.scrollTop += opts.scroll;\n                        else if (cCoors.scrollX && (pEnd.x - cCoors.x < opts.scrollEdge))\n                            element.scrollLeft -= opts.scroll;\n                        else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && (cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge))\n                            element.scrollLeft += opts.scroll;\n\n                        if (opts.compute) {\n                            // Compute selection\n                            if (opts.throttle) {\n                                // Throttle calls to compute\n                                if (!throttled) {\n                                    throttled = true;\n                                    setTimeout(function () {\n                                        throttled && self.compute() && opts.move.apply(self, [e, self.coors, self.selected]);\n                                        throttled = false;\n                                    }, opts.throttle);\n                                }\n                            } else {\n                                self.compute();\n                                opts.move.apply(self, [e, self.coors, self.selected]);\n                            }\n                        }\n                    }\n                }\n            };\n            self._onEnd = function (e) {\n                if (self.opts.enabled &&\n                    started &&\n                    (e.type !== 'mouseup' || e.which === 1)) {\n                    started = false;\n                    if (e.currentTarget === self.currentTarget) {\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n                        throttled = false;  // Don't run throttled compute after noose action already completed\n                        opts.compute && self.compute(true);\n                        setTimeout(function () {\n                            opts.stop.apply(self, [e, self.coors, self.selected]);\n                        }, 0);\n                        self.currentTarget.removeChild(noose);\n                    }\n                }\n            };\n            // Register handlers\n            Array.prototype.forEach.call(self.containers, function (container) {\n                // Fixing chrome mobile touch event issue\n                // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n                container.addEventListener('mousedown', self._onStart);\n                container.addEventListener('touchstart', self._onStart, false);\n                container.addEventListener('mousemove', self._onMove);\n                container.addEventListener('touchmove', self._onMove, false);\n                container.addEventListener('scroll', self._onMove);\n                container.addEventListener('mouseup', self._onEnd);\n                container.addEventListener('touchend', self._onEnd, false);\n\n                container.noose = self;\n            });\n\n            return self;\n        }\n        /**\n         * Destroy this Noose instance.\n         *\n         * @returns {Noose} This instance.\n         */\n        destroy() {\n            const self = this;\n            self.containers.forEach(function (container) {\n                container.removeEventListener('mousedown', self._onStart);\n                container.removeEventListener('touchstart', self._onStart);\n                container.removeEventListener('mousemove', self._onMove);\n                container.removeEventListener('touchmove', self._onMove);\n                container.removeEventListener('scroll', self._onMove);\n                container.removeEventListener('mouseup', self._onEnd);\n                container.removeEventListener('touchend', self._onEnd);\n\n                delete container.noose;\n            });\n            self.noose.remove();\n            self.noose = null;\n\n            return self;\n        }\n        /**\n         * Update the current container's position.\n         * \n         * @returns {Noose} This instance.\n         */\n        updateContainerPosition() {\n            const cCoors = this.coors.container;\n            const rect = this.currentTarget.getBoundingClientRect();\n            // Get position relative to the document's top left origin\n            cCoors.x = rect.left + window.pageXOffset;\n            cCoors.y = rect.top + window.pageYOffset;\n            cCoors.w = rect.width;\n            cCoors.h = rect.height;\n\n            return this;\n        }\n        /**\n         * Update the current pointer (mouse/touch) position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updatePointerPosition(e) {\n            const root = e && e.touches && e.touches[0] || e;\n            const pCoors = this.coors.pointer;\n\n            if (root && typeof root.pageX === 'number') {\n                // Get position relative to the document's top left origin\n\n                // Current position is always end\n                pCoors.end = {\n                    x: root.pageX,\n                    y: root.pageY\n                };\n                // Keep start static\n                if (!pCoors.start) {\n                    pCoors.start = pCoors.end;\n                }\n            }\n\n            return this;\n        }\n        /**\n         * Updates the noose top/bottom position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updateNoosePosition() {\n            const element = this.currentTarget;\n            const pEnd = this.coors.pointer.end;\n            const cCoors = this.coors.container;\n            const nCoors = this.coors.noose;\n            // Pointer and container are both relative to document top left origin.\n            // The noose is positioned absolute relative to the container. So that's\n            // (pointer - container), and also account for the container's scroll position.\n            const endX = _max(pEnd.x - cCoors.x + element.scrollLeft, 0);\n            const endY = _max(pEnd.y - cCoors.y + element.scrollTop, 0);\n\n            if (!nCoors.start) {\n                // Keep start position static\n                nCoors.start = {\n                    x: endX,\n                    y: endY\n                };\n            }\n\n            // Determine top and bottom of the noose\n            // top < bottom\n            nCoors.top = {\n                x: _min(nCoors.start.x, endX),\n                y: _min(nCoors.start.y, endY)\n            };\n            nCoors.bottom = {\n                x: _min(_max(nCoors.start.x, endX), element.scrollWidth),\n                y: _min(_max(nCoors.start.y, endY), element.scrollHeight)\n            };\n\n            return this;\n        }\n        /**\n         * Compute the selected elements within the noose region.\n         *\n         * @returns {Noose} This instance.\n         */\n        compute() {\n            const self = this;\n            // Only do if select is enabled\n            if (self.opts.select) {\n                const className = self.opts.classes.selected;\n                const container = self.currentTarget;\n                const elements = container.querySelectorAll(self.opts.select);\n                const nTop = self.coors.noose.top;\n                const nBottom = self.coors.noose.bottom;\n                const offsetX = self.coors.container.x;\n                const offsetY = self.coors.container.y;\n\n                self.selected = [];\n\n                Array.prototype.forEach.call(elements, function (element) {\n                    if (element === self.noose) return; // Don't include noose\n\n                    let include;\n                    // Get absolute position of element relative to container\n                    const rect = element.getBoundingClientRect();\n                    const topX = rect.left + window.pageXOffset - offsetX + container.scrollLeft;\n                    const topY = rect.top + window.pageYOffset - offsetY + container.scrollTop;\n                    const bottomX = rect.width + topX;\n                    const bottomY = rect.height + topY;\n\n                    if (self.opts.mode === 'fit') {\n                        // Include is entire element is within noose\n                        include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\n                    } else {\n                        // Include if partially touching\n                        include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\n                    }\n\n                    const idx = self.lastSelection.indexOf(element);\n\n                    if (include && idx === -1 || !include && idx !== -1) {\n                        className && element.classList.add(className);\n                        self.selected.push(element);\n                    } else {\n                        className && element.classList.remove(className);\n                    }\n                });\n            }\n\n            return self;\n        }\n        /**\n         * Get the current version.\n         */\n        static get version() {\n            return '1.0.0';\n        }\n    }\n\n    return Noose;\n}, window, document));\n"]}