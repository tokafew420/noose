{"version":3,"sources":["noose.js"],"names":["factory","window","document","exports","module","define","amd","Noose","noop","defaults","container","classes","noose","selected","enabled","mode","scroll","scrollEdge","scrollbar","select","start","stop","style","border","zIndex","throttle","[object Object]","opts","self","this","Element","Object","assign","containers","Error","querySelectorAll","coors","pointer","end","top","bottom","createElement","position","classList","add","started","throttled","_onStart","e","currentTarget","type","which","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","updateContainerPosition","updatePointerPosition","x","w","y","h","display","apply","defaultPrevented","appendChild","_onMove","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","compute","_onEnd","removeChild","Array","prototype","forEach","call","addEventListener","removeEventListener","containerCoors","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pos","pageY","endX","endY","Math","min","max","className","elements","offsetX","offsetY","element","topX","topY","bottomX","bottomY","push","remove","version"],"mappings":"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","file":"noose.js","sourcesContent":["(function (factory, window, document) {\n    if (typeof exports === 'object') {\n        // CommonJS\n        module.exports = factory(window, document);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(() => {\n            return factory(window, document)\n        });\n    } else {\n        window.Noose = factory(window, document);\n    }\n}(function (window, document) {\n    'use strict';\n\n    function noop() {}\n\n    // Default options\n    const defaults = {\n        // Containing element for the noose\n        container: 'body',\n        // Classes for styling\n        classes: {\n            noose: '',\n            selected: 'selected'\n        },\n        // Whether the noose is enabled\n        enabled: true,\n        // The selection mode, part or whole\n        mode: 'touch',\n        // The amount of pixels to scroll\n        scroll: 10,\n        // The edge offset when scrolling should happen\n        scrollEdge: 10,\n        // The scrollbar size\n        scrollbar: 17,\n        // Elements to select\n        select: '*',\n        // On noose-ing start handler\n        start: noop,\n        // On noose-ing stop handler\n        stop: noop,\n        // Styles for the noose\n        style: {\n            border: '1px dotted #000',\n            zIndex: 1000\n        },\n        // Throttle calls to compute selection\n        throttle: 200\n    };\n\n    class Noose {\n        constructor(container, opts) {\n            var self = this;\n            // Parse arguments\n            if (typeof container === 'object' && container != null && !(container instanceof Element)) {\n                opts = container;\n                container = null;\n            }\n            opts = self.opts = Object.assign({}, defaults, opts);\n            // Container must be position (anything but static)\n            if (typeof container === 'string' || container instanceof Element) {\n                opts.container = container;\n            }\n            // Get containers\n            if (opts.container instanceof Element) {\n                self.containers = [opts.container];\n            } else if (typeof opts.container === 'string') {\n                self.containers = document.querySelectorAll(opts.container);\n            } else {\n                throw new Error('Invalid container option');\n            }\n            // Setup states\n            self.coors = {\n                // Relative to document top left origin\n                pointer: {\n                    start: null,\n                    end: null // The current/end position of the mouse/touch\n                },\n                // Relative to container\n                noose: {\n                    top: null,\n                    bottom: null // The bottom right position of the noose\n                },\n                // Relative to document top left origin\n                container: {}\n            };\n            // Create noose\n            var noose = self.noose = document.createElement('div');\n            noose.style.position = 'absolute';\n            noose.style.zIndex = self.opts.style.zIndex;\n            noose.style.border = self.opts.style.border;\n            if (opts.classes.noose) {\n                noose.classList.add(self.opts.classes.noose);\n            }\n            var started = false; // Flag for noose-ing started\n            var throttled = false;\n            self._onStart = function (e) {\n                if (self.opts.enabled &&\n                    (!started || e.currentTarget !== self.currentTarget) &&\n                    (e.type !== 'mousedown' || e.which === 1)) {\n                    started = true;\n                    self.currentTarget = e.currentTarget;\n                    // Initialize container values\n                    var style = window.getComputedStyle(self.currentTarget);\n                    if (style.position === 'static') {\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n                    }\n                    var container = self.coors.container;\n                    var pointer = self.coors.pointer;\n                    var noose = self.coors.noose;\n                    // Does the container have scrollbars\n                    if (self.opts.scroll > 0 && self.opts.scrollEdge > 0) {\n                        container.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && self.currentTarget.scrollHeight > self.currentTarget.clientHeight;\n                        container.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && self.currentTarget.scrollWidth > self.currentTarget.clientWidth;\n                    } else {\n                        container.scrollX = false;\n                        container.scrollY = false;\n                    }\n                    // Set the max allowed scroll amount\n                    container.maxScrollY = container.scrollY && self.currentTarget.scrollHeight - self.currentTarget.clientHeight || 0;\n                    container.maxScrollX = container.scrollX && self.currentTarget.scrollWidth - self.currentTarget.clientWidth || 0;\n                    // Reset start positions\n                    pointer.start = null;\n                    noose.start = null;\n                    self.updateContainerPosition().updatePointerPosition(e);\n                    // If the scrollbar was click then don't start\n                    if (self.opts.scrollbar &&\n                        ((container.scrollX && pointer.start.x > (container.x + container.w - self.opts.scrollbar) ||\n                            container.scrollY && pointer.start.y > (container.y + container.h - self.opts.scrollbar)))) {\n                        started = false;\n                        return;\n                    }\n                    self.noose.style.display = 'none';\n                    if (self.opts.start.apply(self, [e, self.coors]) === false || e.defaultPrevented) {\n                        started = false;\n                        return;\n                    }\n                    self.currentTarget.appendChild(self.noose);\n                }\n            };\n            self._onMove = function (e) {\n                if (self.opts.enabled) {\n                    if (started && e.currentTarget === self.currentTarget) {\n                        e.preventDefault();\n                        if (e.type !== 'scroll') {\n                            self.updatePointerPosition(e);\n                        }\n                        self.updateContainerPosition().updateNoosePosition();\n                        // Draw noose\n                        var top = self.coors.noose.top;\n                        var bottom = self.coors.noose.bottom;\n                        self.noose.style.left = top.x + 'px';\n                        self.noose.style.top = top.y + 'px';\n                        self.noose.style.width = (bottom.x - top.x) + 'px';\n                        self.noose.style.height = (bottom.y - top.y) + 'px';\n                        self.noose.style.display = 'block';\n                        // Scroll container\n                        var container = self.coors.container;\n                        var pointer = self.coors.pointer.end;\n                        if (container.scrollY && (pointer.y - container.y < 10))\n                            self.currentTarget.scrollTop -= self.opts.scroll;\n                        else if (container.scrollY && self.currentTarget.scrollTop < container.maxScrollY && (container.y + container.h - pointer.y < 10))\n                            self.currentTarget.scrollTop += self.opts.scroll;\n                        else if (container.scrollX && (pointer.x - container.x < 10))\n                            self.currentTarget.scrollLeft -= self.opts.scroll;\n                        else if (container.scrollX && self.currentTarget.scrollLeft < container.maxScrollX && (container.x + container.w - pointer.x < 10))\n                            self.currentTarget.scrollLeft += self.opts.scroll;\n                        // Compute selection\n                        if (self.opts.throttle) {\n                            // Throttle calls to compute\n                            if (!throttled) {\n                                throttled = true;\n                                setTimeout(function () {\n                                    self.compute();\n                                    throttled = false;\n                                }, self.opts.throttle);\n                            }\n                        } else {\n                            self.compute();\n                        }\n                    }\n                }\n            };\n            self._onEnd = function (e) {\n                if (self.opts.enabled &&\n                    started &&\n                    (e.type !== 'mouseup' || e.which === 1)) {\n                    started = false;\n                    if (e.currentTarget === self.currentTarget) {\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n                        self.compute();\n                        setTimeout(function () {\n                            self.opts.stop.apply(self, [e, self.coors, self.selected]);\n                        }, 0);\n                        self.currentTarget.removeChild(self.noose);\n                    }\n                }\n            };\n            // Register handlers\n            Array.prototype.forEach.call(self.containers, function (container) {\n                container.addEventListener('mousedown', self._onStart);\n                container.addEventListener('touchstart', self._onStart);\n                container.addEventListener('mousemove', self._onMove);\n                container.addEventListener('touchmove', self._onMove);\n                container.addEventListener('scroll', self._onMove);\n                container.addEventListener('mouseup', self._onEnd);\n                container.addEventListener('touchend', self._onEnd);\n            });\n            return self;\n        }\n        /**\n         * Destroy this Noose instance.\n         *\n         * @returns {Noose} This instance.\n         */\n        destroy() {\n            var self = this;\n            self.containers.forEach(function (container) {\n                container.removeEventListener('mousedown', self._onStart);\n                container.removeEventListener('touchstart', self._onStart);\n                container.removeEventListener('mousemove', self._onMove);\n                container.removeEventListener('touchmove', self._onMove);\n                container.removeEventListener('scroll', self._onMove);\n                container.removeEventListener('mouseup', self._onEnd);\n                container.removeEventListener('touchend', self._onEnd);\n            });\n            return self;\n        }\n        /**\n         * Update the current container's position.\n         * \n         * @returns {Noose} This instance.\n         */\n        updateContainerPosition() {\n            var container = this.currentTarget;\n            var containerCoors = this.coors.container;\n            var rect = container.getBoundingClientRect();\n            // Get position relative to the document's top left origin\n            containerCoors.x = rect.left + window.pageXOffset;\n            containerCoors.y = rect.top + window.pageYOffset;\n            containerCoors.w = rect.width;\n            containerCoors.h = rect.height;\n            return this;\n        }\n        /**\n         * Update the current pointer (mouse/touch) position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updatePointerPosition(e) {\n            var root = e && e.touches && e.touches[0] || e;\n            var pointer = this.coors.pointer;\n\n            if (root && typeof root.pageX === 'number') {\n                // Get position relative to the document's top left origin\n                var pos = {\n                    x: root.pageX,\n                    y: root.pageY\n                };\n                // Keep start static\n                if (!pointer.start)\n                    pointer.start = pos;\n                // Current position is always end\n                pointer.end = pos;\n            }\n\n            return this;\n        }\n        /**\n         * Updates the noose top/bottom position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updateNoosePosition() {\n            var currentTarget = this.currentTarget;\n            var pointer = this.coors.pointer;\n            var container = this.coors.container;\n            var noose = this.coors.noose;\n            // Pointer and container are both relative to document top left origin.\n            // The noose is positioned absolute relative to the container. So that's\n            // (pointer - container), and also account for the container's scroll position.\n            if (!noose.start) {\n                // Keep start position static\n                noose.start = {\n                    x: pointer.start.x - container.x + currentTarget.scrollLeft,\n                    y: pointer.start.y - container.y + currentTarget.scrollTop\n                };\n            }\n            var endX = pointer.end.x - container.x + currentTarget.scrollLeft;\n            var endY = pointer.end.y - container.y + currentTarget.scrollTop;\n            // Determine top and bottom of the noose\n            // top < bottom\n            noose.top = {\n                x: Math.min(noose.start.x, endX),\n                y: Math.min(noose.start.y, endY)\n            };\n            noose.bottom = {\n                x: Math.max(noose.start.x, endX),\n                y: Math.max(noose.start.y, endY)\n            };\n            return this;\n        }\n        /**\n         * Compute the selected elements within the noose region.\n         *\n         * @returns {Noose} This instance.\n         */\n        compute() {\n            var self = this;\n            // Only do if select is enabled\n            if (self.opts.select) {\n                var className = self.opts.classes.selected;\n                var elements = self.currentTarget.querySelectorAll(self.opts.select);\n                var top = self.coors.noose.top;\n                var bottom = self.coors.noose.bottom;\n                var offsetX = self.coors.container.x;\n                var offsetY = self.coors.container.y;\n                self.selected = [];\n                Array.prototype.forEach.call(elements, function (element) {\n                    if (element === self.noose)\n                        return;\n                    var include = false;\n                    // Get absolution position of element relative to container\n                    var rect = element.getBoundingClientRect();\n                    var topX = rect.left + window.pageXOffset - offsetX + self.currentTarget.scrollLeft;\n                    var topY = rect.top + window.pageYOffset - offsetY + self.currentTarget.scrollTop;\n                    var bottomX = rect.width + topX;\n                    var bottomY = rect.height + topY;\n                    if (self.opts.mode === 'fit') {\n                        // Include is entire element is within noose\n                        include = top.x <= topX && top.y <= topY && bottom.x >= bottomX && bottom.y >= bottomY;\n                    } else {\n                        // Include if partially touching\n                        include = !(top.x > bottomX || top.y > bottomY || bottom.x < topX || bottom.y < topY);\n                    }\n                    if (include) {\n                        className && element.classList.add(className);\n                        self.selected.push(element);\n                    } else {\n                        className && element.classList.remove(className);\n                    }\n                });\n            }\n            return self;\n        }\n        /**\n         * Get the current version.\n         */\n        get version() {\n            return '1.0.0';\n        }\n    }\n\n    return Noose;\n}, window, document));\n"]}