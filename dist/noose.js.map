{"version":3,"sources":["noose.js"],"names":["factory","window","document","exports","module","define","amd","Noose","noop","defaults","container","classes","noose","selected","enabled","mode","scroll","scrollEdge","scrollbar","select","start","stop","style","border","zIndex","throttle","[object Object]","opts","self","this","Element","Object","assign","containers","Error","querySelectorAll","coors","pointer","end","top","bottom","createElement","position","classList","add","started","throttled","_onStart","e","which","currentTarget","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","updateContainerPosition","updatePointerPosition","x","w","y","h","display","apply","defaultPrevented","appendChild","_onMove","preventDefault","type","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","compute","_onEnd","removeChild","Array","prototype","forEach","call","addEventListener","removeEventListener","containerCoors","rect","getBoundingClientRect","pageXOffset","pageYOffset","pos","pageX","pageY","endX","endY","Math","min","max","className","elements","offsetX","offsetY","element","topX","topY","bottomX","bottomY","push","remove","version"],"mappings":"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","file":"noose.js","sourcesContent":["(function (factory, window, document) {\n    if (typeof exports === 'object') {\n        // CommonJS\n        module.exports = factory(window, document);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(() => {\n            return factory(window, document)\n        });\n    } else {\n        window.Noose = factory(window, document);\n    }\n}(function (window, document) {\n    'use strict';\n\n    function noop() {}\n\n    // Default options\n    const defaults = {\n        // Containing element for the noose\n        container: 'body',\n        // Classes for styling\n        classes: {\n            noose: '',\n            selected: 'selected'\n        },\n        // Whether the noose is enabled\n        enabled: true,\n        // The selection mode, part or whole\n        mode: 'touch',\n        // The amount of pixels to scroll\n        scroll: 10,\n        // The edge offset when scrolling should happen\n        scrollEdge: 10,\n        // The scrollbar size\n        scrollbar: 17,\n        // Elements to select\n        select: '*',\n        // On noose-ing start handler\n        start: noop,\n        // On noose-ing stop handler\n        stop: noop,\n        // Styles for the noose\n        style: {\n            border: '1px dotted #000',\n            zIndex: 1000\n        },\n        // Throttle calls to compute selection\n        throttle: 200\n    };\n\n    class Noose {\n        constructor(container, opts) {\n            var self = this;\n            // Parse arguments\n            if (typeof container === 'object' && container != null && !(container instanceof Element)) {\n                opts = container;\n                container = null;\n            }\n            opts = self.opts = Object.assign({}, defaults, opts);\n            // Container must be position (anything but static)\n            if (typeof container === 'string' || container instanceof Element) {\n                opts.container = container;\n            }\n            // Get containers\n            if (opts.container instanceof Element) {\n                self.containers = [opts.container];\n            } else if (typeof opts.container === 'string') {\n                self.containers = document.querySelectorAll(opts.container);\n            } else {\n                throw new Error('Invalid container option');\n            }\n            // Setup states\n            self.coors = {\n                // Relative to document top left origin\n                pointer: {\n                    start: null,\n                    end: null // The current/end position of the mouse/touch\n                },\n                // Relative to container\n                noose: {\n                    top: null,\n                    bottom: null // The bottom right position of the noose\n                },\n                // Relative to document top left origin\n                container: {}\n            };\n            // Create noose\n            var noose = self.noose = document.createElement('div');\n            noose.style.position = 'absolute';\n            noose.style.zIndex = self.opts.style.zIndex;\n            noose.style.border = self.opts.style.border;\n            if (opts.classes.noose) {\n                noose.classList.add(self.opts.classes.noose);\n            }\n            var started = false; // Flag for noose-ing started\n            var throttled = false;\n            self._onStart = function (e) {\n                if (e.which === 1 &\n                    self.opts.enabled &&\n                    (!started || e.currentTarget !== self.currentTarget)) {\n                    started = true;\n                    self.currentTarget = e.currentTarget;\n                    // Initialize container values\n                    var style = window.getComputedStyle(self.currentTarget);\n                    if (style.position === 'static') {\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n                    }\n                    var container = self.coors.container;\n                    var pointer = self.coors.pointer;\n                    var noose = self.coors.noose;\n                    // Does the container have scrollbars\n                    if (self.opts.scroll > 0 && self.opts.scrollEdge > 0) {\n                        container.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && self.currentTarget.scrollHeight > self.currentTarget.clientHeight;\n                        container.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && self.currentTarget.scrollWidth > self.currentTarget.clientWidth;\n                    } else {\n                        container.scrollX = false;\n                        container.scrollY = false;\n                    }\n                    // Set the max allowed scroll amount\n                    container.maxScrollY = container.scrollY && self.currentTarget.scrollHeight - self.currentTarget.clientHeight || 0;\n                    container.maxScrollX = container.scrollX && self.currentTarget.scrollWidth - self.currentTarget.clientWidth || 0;\n                    // Reset start positions\n                    pointer.start = null;\n                    noose.start = null;\n                    self.updateContainerPosition().updatePointerPosition(e);\n                    // If the scrollbar was click then don't start\n                    if (self.opts.scrollbar &&\n                        ((container.scrollX && pointer.start.x > (container.x + container.w - self.opts.scrollbar) ||\n                            container.scrollY && pointer.start.y > (container.y + container.h - self.opts.scrollbar)))) {\n                        started = false;\n                        return;\n                    }\n                    self.noose.style.display = 'none';\n                    if (self.opts.start.apply(self, [e, self.coors]) === false || e.defaultPrevented) {\n                        started = false;\n                        return;\n                    }\n                    self.currentTarget.appendChild(self.noose);\n                }\n            };\n            self._onMove = function (e) {\n                if (self.opts.enabled) {\n                    if (started && e.currentTarget === self.currentTarget) {\n                        e.preventDefault();\n                        if (e.type !== 'scroll') {\n                            self.updatePointerPosition(e);\n                        }\n                        self.updateContainerPosition().updateNoosePosition();\n                        // Draw noose\n                        var top = self.coors.noose.top;\n                        var bottom = self.coors.noose.bottom;\n                        self.noose.style.left = top.x + 'px';\n                        self.noose.style.top = top.y + 'px';\n                        self.noose.style.width = (bottom.x - top.x) + 'px';\n                        self.noose.style.height = (bottom.y - top.y) + 'px';\n                        self.noose.style.display = 'block';\n                        // Scroll container\n                        var container = self.coors.container;\n                        var pointer = self.coors.pointer.end;\n                        if (container.scrollY && (pointer.y - container.y < 10))\n                            self.currentTarget.scrollTop -= self.opts.scroll;\n                        else if (container.scrollY && self.currentTarget.scrollTop < container.maxScrollY && (container.y + container.h - pointer.y < 10))\n                            self.currentTarget.scrollTop += self.opts.scroll;\n                        else if (container.scrollX && (pointer.x - container.x < 10))\n                            self.currentTarget.scrollLeft -= self.opts.scroll;\n                        else if (container.scrollX && self.currentTarget.scrollLeft < container.maxScrollX && (container.x + container.w - pointer.x < 10))\n                            self.currentTarget.scrollLeft += self.opts.scroll;\n                        // Compute selection\n                        if (self.opts.throttle) {\n                            // Throttle calls to compute\n                            if (!throttled) {\n                                throttled = true;\n                                setTimeout(function () {\n                                    self.compute();\n                                    throttled = false;\n                                }, self.opts.throttle);\n                            }\n                        } else {\n                            self.compute();\n                        }\n                    }\n                }\n            };\n            self._onEnd = function (e) {\n                if (e.which === 1 && self.opts.enabled && started) {\n                    started = false;\n                    if (e.currentTarget === self.currentTarget) {\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n                        self.compute();\n                        setTimeout(function () {\n                            self.opts.stop.apply(self, [e, self.coors, self.selected]);\n                        }, 0);\n                        self.currentTarget.removeChild(self.noose);\n                    }\n                }\n            };\n            // Register handlers\n            Array.prototype.forEach.call(self.containers, function (container) {\n                container.addEventListener('mousedown', self._onStart);\n                container.addEventListener('mousemove', self._onMove);\n                container.addEventListener('scroll', self._onMove);\n                container.addEventListener('mouseup', self._onEnd);\n            });\n            return self;\n        }\n        /**\n         * Destroy this Noose instance.\n         *\n         * @returns {Noose} This instance.\n         */\n        destroy() {\n            var self = this;\n            self.containers.forEach(function (container) {\n                container.removeEventListener('mousedown', self._onStart);\n                container.removeEventListener('mousemove', self._onMove);\n                container.removeEventListener('scroll', self._onMove);\n                container.removeEventListener('mouseup', self._onEnd);\n            });\n            return self;\n        }\n        /**\n         * Update the current container's position.\n         * \n         * @returns {Noose} This instance.\n         */\n        updateContainerPosition() {\n            var container = this.currentTarget;\n            var containerCoors = this.coors.container;\n            var rect = container.getBoundingClientRect();\n            // Get position relative to the document's top left origin\n            containerCoors.x = rect.left + window.pageXOffset;\n            containerCoors.y = rect.top + window.pageYOffset;\n            containerCoors.w = rect.width;\n            containerCoors.h = rect.height;\n            return this;\n        }\n        /**\n         * Update the current pointer (mouse/touch) position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updatePointerPosition(e) {\n            var pointer = this.coors.pointer;\n            // Get position relative to the document's top left origin\n            var pos = {\n                x: e.pageX,\n                y: e.pageY\n            };\n            // Keep start static\n            if (!pointer.start)\n                pointer.start = pos;\n            // Current position is always end\n            pointer.end = pos;\n            return this;\n        }\n        /**\n         * Updates the noose top/bottom position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updateNoosePosition() {\n            var currentTarget = this.currentTarget;\n            var pointer = this.coors.pointer;\n            var container = this.coors.container;\n            var noose = this.coors.noose;\n            // Pointer and container are both relative to document top left origin.\n            // The noose is positioned absolute relative to the container. So that's\n            // (pointer - container), and also account for the container's scroll position.\n            if (!noose.start) {\n                // Keep start position static\n                noose.start = {\n                    x: pointer.start.x - container.x + currentTarget.scrollLeft,\n                    y: pointer.start.y - container.y + currentTarget.scrollTop\n                };\n            }\n            var endX = pointer.end.x - container.x + currentTarget.scrollLeft;\n            var endY = pointer.end.y - container.y + currentTarget.scrollTop;\n            // Determine top and bottom of the noose\n            // top < bottom\n            noose.top = {\n                x: Math.min(noose.start.x, endX),\n                y: Math.min(noose.start.y, endY)\n            };\n            noose.bottom = {\n                x: Math.max(noose.start.x, endX),\n                y: Math.max(noose.start.y, endY)\n            };\n            return this;\n        }\n        /**\n         * Compute the selected elements within the noose region.\n         *\n         * @returns {Noose} This instance.\n         */\n        compute() {\n            var self = this;\n            // Only do if select is enabled\n            if (self.opts.select) {\n                var className = self.opts.classes.selected;\n                var elements = self.currentTarget.querySelectorAll(self.opts.select);\n                var top = self.coors.noose.top;\n                var bottom = self.coors.noose.bottom;\n                var offsetX = self.coors.container.x;\n                var offsetY = self.coors.container.y;\n                self.selected = [];\n                Array.prototype.forEach.call(elements, function (element) {\n                    if (element === self.noose)\n                        return;\n                    var include = false;\n                    // Get absolution position of element relative to container\n                    var rect = element.getBoundingClientRect();\n                    var topX = rect.left + window.pageXOffset - offsetX + self.currentTarget.scrollLeft;\n                    var topY = rect.top + window.pageYOffset - offsetY + self.currentTarget.scrollTop;\n                    var bottomX = rect.width + topX;\n                    var bottomY = rect.height + topY;\n                    if (self.opts.mode === 'fit') {\n                        // Include is entire element is within noose\n                        include = top.x <= topX && top.y <= topY && bottom.x >= bottomX && bottom.y >= bottomY;\n                    } else {\n                        // Include if partially touching\n                        include = !(top.x > bottomX || top.y > bottomY || bottom.x < topX || bottom.y < topY);\n                    }\n                    if (include) {\n                        className && element.classList.add(className);\n                        self.selected.push(element);\n                    } else {\n                        className && element.classList.remove(className);\n                    }\n                });\n            }\n            return self;\n        }\n        /**\n         * Get the current version.\n         */\n        get version() {\n            return '1.0.0';\n        }\n    }\n\n    return Noose;\n}, window, document));\n"]}