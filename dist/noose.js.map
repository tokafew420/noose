{"version":3,"file":"noose.js","names":["factory","window","document","exports","module","define","amd","Noose","noop","_min","Math","min","_max","max","_unit","defaults","classes","noose","selected","compute","container","containers","ctrl","detach","enabled","mode","move","scroll","scrollEdge","scrollbar","select","shift","start","stop","style","border","zIndex","throttle","constructor","opts","self","this","HTMLElement","Object","assign","Error","Array","prototype","slice","call","querySelectorAll","coors","pointer","createElement","position","classList","add","started","throttled","_onStart","e","sameContainer","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","pStart","pEnd","end","updateContainerPosition","updatePointerPosition","x","w","y","h","shiftKey","nTop","top","nBottom","bottom","midX","floor","midY","ctrlKey","lastSelection","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","_onEnd","removeChild","forEach","_register","destroy","_deregister","remove","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","endY","className","elements","offsetX","offsetY","include","topX","topY","bottomX","bottomY","idx","indexOf","push","removeEventListener","deregister","splice","addEventListener","register","version"],"sources":["noose.js"],"mappings":"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","sourcesContent":["/**\r\n * Noose\r\n * \r\n * version: 1.0.0\r\n */\r\n\r\n(function (factory, window, document) {\r\n    if (typeof exports === 'object') {\r\n        // CommonJS\r\n        module.exports = factory(window, document);\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        // AMD\r\n        define(() => {\r\n            return factory(window, document);\r\n        });\r\n    } else {\r\n        window.Noose = factory(window, document);\r\n    }\r\n}(function (window, document) {\r\n    'use strict';\r\n\r\n    function noop() { }\r\n    const _min = Math.min;\r\n    const _max = Math.max;\r\n    const _unit = 'px';\r\n\r\n    // Default options\r\n    const defaults = {\r\n        // Classes for styling\r\n        classes: {\r\n            noose: 'noose',\r\n            selected: 'selected'\r\n        },\r\n        // Enable/disable computing of selected elements\r\n        compute: true,\r\n        // Containing element for the noose\r\n        container: 'body',\r\n        // Array of containers registered on this instance.\r\n        containers: [],\r\n        // Enable/disable support for ctrl key\r\n        ctrl: true,\r\n        // Whether to detach the noose from the container after noosing\r\n        detach: true,\r\n        // Whether the noose is enabled\r\n        enabled: true,\r\n        // The selection mode, part or whole\r\n        mode: 'touch',\r\n        // On noose move\r\n        move: noop,\r\n        // The amount of pixels to scroll\r\n        scroll: 10,\r\n        // The edge offset when scrolling should happen\r\n        scrollEdge: 10,\r\n        // The scrollbar size\r\n        scrollbar: 17,\r\n        // Elements to select\r\n        select: '*',\r\n        // Enabled/disable support for shift key\r\n        shift: true,\r\n        // On noose-ing start handler\r\n        start: noop,\r\n        // On noose-ing stop handler\r\n        stop: noop,\r\n        // Styles for the noose\r\n        style: {\r\n            border: '1px dotted #000',\r\n            zIndex: 1000\r\n        },\r\n        // Throttle calls to compute selection\r\n        throttle: 200\r\n    };\r\n\r\n    class Noose {\r\n        constructor(container, opts) {\r\n            const self = this;\r\n            // Parse arguments\r\n            if (typeof container === 'object' && container != null && !(container instanceof HTMLElement)) {\r\n                opts = container;\r\n                container = null;\r\n            }\r\n            opts = self.opts = Object.assign({}, defaults, opts);\r\n            // Container must be positioned (anything but static)\r\n            if (typeof container === 'string' || container instanceof HTMLElement) {\r\n                opts.container = container;\r\n            }\r\n            // Get containers\r\n            if (opts.container instanceof HTMLElement) {\r\n                self.containers = [opts.container];\r\n            } else if (typeof opts.container === 'string') {\r\n                self.containers = Array.prototype.slice.call(document.querySelectorAll(opts.container));\r\n            } else {\r\n                throw new Error('Invalid container option');\r\n            }\r\n            // Setup states\r\n            self.coors = {\r\n                // Relative to document top left origin\r\n                pointer: {},\r\n                // Relative to container\r\n                noose: {},\r\n                // Relative to document top left origin\r\n                container: {}\r\n            };\r\n            // Create noose\r\n            const noose = self.noose = document.createElement('div');\r\n            noose.style.position = 'absolute';\r\n            noose.style.zIndex = opts.style.zIndex;\r\n            noose.style.border = opts.style.border;\r\n            if (opts.classes.noose) {\r\n                noose.classList.add(opts.classes.noose);\r\n            }\r\n            let started = false; // Flag for noose-ing started\r\n            let throttled = false;\r\n            self._onStart = function (e) {\r\n                const sameContainer = e.currentTarget === self.currentTarget;\r\n                if (opts.enabled &&\r\n                    (!started || !sameContainer) &&\r\n                    (e.type !== 'mousedown' || e.which === 1)) {\r\n                    started = true;\r\n                    const element = self.currentTarget = e.currentTarget;\r\n                    const cCoors = self.coors.container;\r\n                    const pCoors = self.coors.pointer;\r\n                    const nCoors = self.coors.noose;\r\n\r\n                    // Initialize container values\r\n                    const style = window.getComputedStyle(element);\r\n                    if (style.position === 'static') {\r\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\r\n                    }\r\n                    // Does the container have scrollbars\r\n                    if (opts.scroll > 0 && opts.scrollEdge > 0) {\r\n                        cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\r\n                        cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\r\n                    } else {\r\n                        cCoors.scrollX = false;\r\n                        cCoors.scrollY = false;\r\n                    }\r\n                    // Set the max allowed scroll amount\r\n                    cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\r\n                    cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0;\r\n\r\n                    // Get previous start coors in case we need to restore them\r\n                    const pStart = pCoors.start;\r\n                    const pEnd = pCoors.end;\r\n\r\n                    // Reset start positions\r\n                    pCoors.start = null;\r\n                    nCoors.start = null;\r\n\r\n                    self.updateContainerPosition().updatePointerPosition(e);\r\n                    // If the scrollbar was click then don't start\r\n                    if (opts.scrollbar &&\r\n                        ((cCoors.scrollX && pCoors.end.x > (cCoors.x + cCoors.w - opts.scrollbar) ||\r\n                            cCoors.scrollY && pCoors.end.y > (cCoors.y + cCoors.h - opts.scrollbar)))) {\r\n                        started = false;\r\n                        pCoors.start = pStart;\r\n                        pCoors.end = pEnd;\r\n                        return;\r\n                    }\r\n\r\n                    // Shift key is pressed, continue noose from previous opposing corner\r\n                    if (opts.shift && sameContainer && e.shiftKey && pStart) {\r\n                        const nTop = nCoors.top;\r\n                        const nBottom = nCoors.bottom;\r\n                        const midX = Math.floor((pStart.x + pEnd.x) / 2);\r\n                        const midY = Math.floor((pStart.y + pEnd.y) / 2);\r\n\r\n                        nCoors.start = {};\r\n                        if (pCoors.start.x >= midX && pCoors.start.y < midY) {\r\n                            // 1st quadrant\r\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\r\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\r\n                            nCoors.start.x = nTop.x;\r\n                            nCoors.start.y = nBottom.y;\r\n                        } else if (pCoors.start.x < midX && pCoors.start.y <= midY) {\r\n                            // 2nd quadrant\r\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\r\n                            pCoors.start.y = _max(pStart.y, pEnd.y);\r\n                            nCoors.start = nBottom;\r\n                        } else if (pCoors.start.x <= midX && pCoors.start.y > midY) {\r\n                            // 3rd quadrant\r\n                            pCoors.start.x = _max(pStart.x, pEnd.x);\r\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\r\n                            nCoors.start.x = nBottom.x;\r\n                            nCoors.start.y = nTop.y;\r\n                        } else if (pCoors.start.x > midX && pCoors.start.y >= midY) {\r\n                            // 4th quadrant\r\n                            pCoors.start.x = _min(pStart.x, pEnd.x);\r\n                            pCoors.start.y = _min(pStart.y, pEnd.y);\r\n                            nCoors.start = nTop;\r\n                        }\r\n                    }\r\n\r\n                    if (opts.ctrl && sameContainer && e.ctrlKey) {\r\n                        self.lastSelection = self.selected || [];\r\n                    } else {\r\n                        self.lastSelection = [];\r\n                    }\r\n\r\n                    noose.style.display = 'none';\r\n\r\n                    if (opts.start.apply(self, [e, self.coors]) === false) {\r\n                        started = false;\r\n                        pCoors.start = pStart;\r\n                        pCoors.end = pEnd;\r\n                        return;\r\n                    }\r\n\r\n                    element.appendChild(noose);\r\n                }\r\n            };\r\n            self._onMove = function (e) {\r\n                if (opts.enabled) {\r\n                    if (started && e.currentTarget === self.currentTarget) {\r\n                        e.cancelable && e.preventDefault();\r\n                        if (e.type !== 'scroll') {\r\n                            self.updatePointerPosition(e);\r\n                        }\r\n                        self.updateContainerPosition().updateNoosePosition();\r\n                        // Draw noose\r\n                        let nTop = self.coors.noose.top;\r\n                        let nBottom = self.coors.noose.bottom;\r\n                        noose.style.left = nTop.x + _unit;\r\n                        noose.style.top = nTop.y + _unit;\r\n                        noose.style.width = (nBottom.x - nTop.x) + _unit;\r\n                        noose.style.height = (nBottom.y - nTop.y) + _unit;\r\n                        noose.style.display = 'block';\r\n\r\n                        // Scroll container\r\n                        let element = self.currentTarget;\r\n                        let cCoors = self.coors.container;\r\n                        let pEnd = self.coors.pointer.end;\r\n                        if (cCoors.scrollY && (pEnd.y - cCoors.y < opts.scrollEdge))\r\n                            element.scrollTop -= opts.scroll;\r\n                        else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && (cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge))\r\n                            element.scrollTop += opts.scroll;\r\n                        else if (cCoors.scrollX && (pEnd.x - cCoors.x < opts.scrollEdge))\r\n                            element.scrollLeft -= opts.scroll;\r\n                        else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && (cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge))\r\n                            element.scrollLeft += opts.scroll;\r\n\r\n                        if (opts.compute) {\r\n                            // Compute selection\r\n                            if (opts.throttle) {\r\n                                // Throttle calls to compute\r\n                                if (!throttled) {\r\n                                    throttled = true;\r\n                                    setTimeout(function () {\r\n                                        throttled && self.compute() && opts.move.apply(self, [e, self.coors, self.selected]);\r\n                                        throttled = false;\r\n                                    }, opts.throttle);\r\n                                }\r\n                            } else {\r\n                                self.compute();\r\n                                opts.move.apply(self, [e, self.coors, self.selected]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            self._onEnd = function (e) {\r\n                if (self.opts.enabled &&\r\n                    started &&\r\n                    (e.type !== 'mouseup' || e.which === 1)) {\r\n                    started = false;\r\n                    if (e.currentTarget === self.currentTarget) {\r\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\r\n                        throttled = false; // Don't run throttled compute after noose action already completed\r\n                        opts.compute && self.compute(true);\r\n                        setTimeout(function () {\r\n                            opts.stop.apply(self, [e, self.coors, self.selected]);\r\n                        }, 0);\r\n                        if (opts.detach) self.currentTarget.removeChild(noose);\r\n                    }\r\n                }\r\n            };\r\n            // Register handlers\r\n            self.containers.forEach(container => {\r\n                self._register(container);\r\n            });\r\n\r\n            return self;\r\n        }\r\n        /**\r\n         * Destroy this Noose instance.\r\n         *\r\n         * @returns {Noose} This instance.\r\n         */\r\n        destroy() {\r\n            const self = this;\r\n            self.containers.forEach(container => {\r\n                self._deregister(container);\r\n            });\r\n            self.noose.remove();\r\n            self.noose = null;\r\n\r\n            return self;\r\n        }\r\n        /**\r\n         * Update the current container's position.\r\n         * \r\n         * @returns {Noose} This instance.\r\n         */\r\n        updateContainerPosition() {\r\n            const cCoors = this.coors.container;\r\n            const rect = this.currentTarget.getBoundingClientRect();\r\n            // Get position relative to the document's top left origin\r\n            cCoors.x = rect.left + window.pageXOffset;\r\n            cCoors.y = rect.top + window.pageYOffset;\r\n            cCoors.w = rect.width;\r\n            cCoors.h = rect.height;\r\n\r\n            return this;\r\n        }\r\n        /**\r\n         * Update the current pointer (mouse/touch) position.\r\n         *\r\n         * @param {Event} e The event that prompted recalculation of the noose (ie: mousemove, touchmove, or scroll).\r\n         * @returns {Noose} This instance.\r\n         */\r\n        updatePointerPosition(e) {\r\n            const root = e && e.touches && e.touches[0] || e;\r\n            const pCoors = this.coors.pointer;\r\n\r\n            if (root && typeof root.pageX === 'number') {\r\n                // Get position relative to the document's top left origin\r\n\r\n                // Current position is always end\r\n                pCoors.end = {\r\n                    x: root.pageX,\r\n                    y: root.pageY\r\n                };\r\n                // Keep start static\r\n                if (!pCoors.start) {\r\n                    pCoors.start = pCoors.end;\r\n                }\r\n            }\r\n\r\n            return this;\r\n        }\r\n        /**\r\n         * Updates the noose top/bottom position.\r\n         *\r\n         * @returns {Noose} This instance.\r\n         */\r\n        updateNoosePosition() {\r\n            const element = this.currentTarget;\r\n            const pEnd = this.coors.pointer.end;\r\n            const cCoors = this.coors.container;\r\n            const nCoors = this.coors.noose;\r\n            // Pointer and container are both relative to document top left origin.\r\n            // The noose is positioned absolute relative to the container. So that's\r\n            // (pointer - container), and also account for the container's scroll position.\r\n            const endX = _max(pEnd.x - cCoors.x + element.scrollLeft, 0);\r\n            const endY = _max(pEnd.y - cCoors.y + element.scrollTop, 0);\r\n\r\n            if (!nCoors.start) {\r\n                // Keep start position static\r\n                nCoors.start = {\r\n                    x: endX,\r\n                    y: endY\r\n                };\r\n            }\r\n\r\n            // Determine top and bottom of the noose\r\n            // top < bottom\r\n            nCoors.top = {\r\n                x: _min(nCoors.start.x, endX),\r\n                y: _min(nCoors.start.y, endY)\r\n            };\r\n            nCoors.bottom = {\r\n                x: _min(_max(nCoors.start.x, endX), element.scrollWidth),\r\n                y: _min(_max(nCoors.start.y, endY), element.scrollHeight)\r\n            };\r\n\r\n            return this;\r\n        }\r\n        /**\r\n         * Compute the selected elements within the noose region.\r\n         *\r\n         * @returns {Noose} This instance.\r\n         */\r\n        compute() {\r\n            const self = this;\r\n            // Only do if select is enabled\r\n            if (self.opts.select) {\r\n                const className = self.opts.classes.selected;\r\n                const container = self.currentTarget;\r\n                const elements = container.querySelectorAll(self.opts.select);\r\n                const nTop = self.coors.noose.top;\r\n                const nBottom = self.coors.noose.bottom;\r\n                const offsetX = self.coors.container.x;\r\n                const offsetY = self.coors.container.y;\r\n\r\n                self.selected = [];\r\n\r\n                Array.prototype.forEach.call(elements, function (element) {\r\n                    if (element === self.noose) return; // Don't include noose\r\n\r\n                    let include;\r\n                    // Get absolute position of element relative to container\r\n                    const rect = element.getBoundingClientRect();\r\n                    const topX = rect.left + window.pageXOffset - offsetX + container.scrollLeft;\r\n                    const topY = rect.top + window.pageYOffset - offsetY + container.scrollTop;\r\n                    const bottomX = rect.width + topX;\r\n                    const bottomY = rect.height + topY;\r\n\r\n                    if (self.opts.mode === 'fit') {\r\n                        // Include if entire element is within noose\r\n                        include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\r\n                    } else {\r\n                        // Include if partially touching\r\n                        include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\r\n                    }\r\n\r\n                    const idx = self.lastSelection.indexOf(element);\r\n\r\n                    if (include && idx === -1 || !include && idx !== -1) {\r\n                        className && element.classList.add(className);\r\n                        self.selected.push(element);\r\n                    } else {\r\n                        className && element.classList.remove(className);\r\n                    }\r\n                });\r\n            }\r\n\r\n            return self;\r\n        }\r\n        _deregister(container) {\r\n            container.removeEventListener('mousedown', this._onStart);\r\n            container.removeEventListener('touchstart', this._onStart);\r\n            container.removeEventListener('mousemove', this._onMove);\r\n            container.removeEventListener('touchmove', this._onMove);\r\n            container.removeEventListener('scroll', this._onMove);\r\n            container.removeEventListener('mouseup', this._onEnd);\r\n            container.removeEventListener('touchend', this._onEnd);\r\n\r\n            delete container.noose;\r\n\r\n            return this;\r\n        }\r\n        /**\r\n         * Deregister a container from the Noose instance.\r\n         * \r\n         * @param {HTMLElement} container The container to remove.\r\n         * @returns {Noose} This instance.\r\n         */\r\n        deregister(container) {\r\n            var idx = this.containers.indexOf(container);\r\n            if (idx > -1 && typeof container.removeEventListener === 'function') {\r\n                this._deregister(container);\r\n                this.containers.splice(idx, 1);\r\n            }\r\n            return this;\r\n        }\r\n        _register(container) {\r\n            // Fixing chrome mobile touch event issue\r\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\r\n            container.addEventListener('mousedown', this._onStart);\r\n            container.addEventListener('touchstart', this._onStart, false);\r\n            container.addEventListener('mousemove', this._onMove);\r\n            container.addEventListener('touchmove', this._onMove, false);\r\n            container.addEventListener('scroll', this._onMove);\r\n            container.addEventListener('mouseup', this._onEnd);\r\n            container.addEventListener('touchend', this._onEnd, false);\r\n\r\n            return container.noose = this;\r\n        }\r\n        /**\r\n         * Register a container to the Noose instance.\r\n         * \r\n         * @param {HTMLElement} container The container to register.\r\n         * @returns {Noose} This instance.\r\n         */\r\n        register(container) {\r\n            var idx = this.containers.indexOf(container);\r\n            if (idx === -1 && typeof container.addEventListener === 'function') {\r\n                this._register(container);\r\n                this.containers.push(container);\r\n            }\r\n            return this;\r\n        }\r\n        /**\r\n         * Get the current version.\r\n         */\r\n        static get version() {\r\n            return '1.0.0';\r\n        }\r\n    }\r\n\r\n    return Noose;\r\n}, window, document));\r\n"]}