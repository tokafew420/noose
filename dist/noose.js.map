{"version":3,"sources":["noose.js"],"names":["factory","window","document","exports","module","define","amd","Noose","noop","defaults","classes","noose","selected","container","enabled","mode","scroll","scrollEdge","scrollbar","select","start","stop","style","border","zIndex","throttle","[object Object]","opts","self","this","HTMLElement","Object","assign","containers","Error","querySelectorAll","coors","pointer","end","top","bottom","createElement","position","classList","add","started","throttled","_onStart","e","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","updateContainerPosition","updatePointerPosition","x","w","y","h","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","nTop","nBottom","left","width","height","pEnd","scrollTop","scrollLeft","setTimeout","compute","_onEnd","removeChild","Array","prototype","forEach","call","addEventListener","removeEventListener","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","Math","max","endY","min","className","elements","offsetX","offsetY","include","topX","topY","bottomX","bottomY","push","remove","version"],"mappings":"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","file":"noose.js","sourcesContent":["/**\n * Noose\n * \n * version: 1.0.0\n */\n\n(function (factory, window, document) {\n    if (typeof exports === 'object') {\n        // CommonJS\n        module.exports = factory(window, document);\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(() => {\n            return factory(window, document)\n        });\n    } else {\n        window.Noose = factory(window, document);\n    }\n}(function (window, document) {\n    'use strict';\n\n    function noop() {}\n\n    // Default options\n    const defaults = {\n        // Classes for styling\n        classes: {\n            noose: 'noose',\n            selected: 'selected'\n        },\n        // Containing element for the noose\n        container: 'body',\n        // Whether the noose is enabled\n        enabled: true,\n        // The selection mode, part or whole\n        mode: 'touch',\n        // The amount of pixels to scroll\n        scroll: 10,\n        // The edge offset when scrolling should happen\n        scrollEdge: 10,\n        // The scrollbar size\n        scrollbar: 17,\n        // Elements to select\n        select: '*',\n        // On noose-ing start handler\n        start: noop,\n        // On noose-ing stop handler\n        stop: noop,\n        // Styles for the noose\n        style: {\n            border: '1px dotted #000',\n            zIndex: 1000\n        },\n        // Throttle calls to compute selection\n        throttle: 200\n    };\n\n    class Noose {\n        constructor(container, opts) {\n            const self = this;\n            // Parse arguments\n            if (typeof container === 'object' && container != null && !(container instanceof HTMLElement)) {\n                opts = container;\n                container = null;\n            }\n            opts = self.opts = Object.assign({}, defaults, opts);\n            // Container must be position (anything but static)\n            if (typeof container === 'string' || container instanceof HTMLElement) {\n                opts.container = container;\n            }\n            // Get containers\n            if (opts.container instanceof HTMLElement) {\n                self.containers = [opts.container];\n            } else if (typeof opts.container === 'string') {\n                self.containers = document.querySelectorAll(opts.container);\n            } else {\n                throw new Error('Invalid container option');\n            }\n            // Setup states\n            self.coors = {\n                // Relative to document top left origin\n                pointer: {\n                    start: null,\n                    end: {} // The current/end position of the mouse/touch\n                },\n                // Relative to container\n                noose: {\n                    top: null,\n                    bottom: null // The bottom right position of the noose\n                },\n                // Relative to document top left origin\n                container: {}\n            };\n            // Create noose\n            const noose = self.noose = document.createElement('div');\n            noose.style.position = 'absolute';\n            noose.style.zIndex = opts.style.zIndex;\n            noose.style.border = opts.style.border;\n            if (opts.classes.noose) {\n                noose.classList.add(opts.classes.noose);\n            }\n            let started = false; // Flag for noose-ing started\n            let throttled = false;\n            self._onStart = function (e) {\n                if (opts.enabled &&\n                    (!started || e.currentTarget !== self.currentTarget) &&\n                    (e.type !== 'mousedown' || e.which === 1)) {\n                    started = true;\n                    const element = self.currentTarget = e.currentTarget;\n                    const cCoors = self.coors.container;\n                    const pCoors = self.coors.pointer;\n                    const nCoors = self.coors.noose;\n\n                    // Initialize container values\n                    const style = window.getComputedStyle(element);\n                    if (style.position === 'static') {\n                        console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n                    }\n                    // Does the container have scrollbars\n                    if (opts.scroll > 0 && opts.scrollEdge > 0) {\n                        cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\n                        cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\n                    } else {\n                        cCoors.scrollX = false;\n                        cCoors.scrollY = false;\n                    }\n                    // Set the max allowed scroll amount\n                    cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\n                    cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0;\n                    // Reset start positions\n                    pCoors.start = null;\n                    nCoors.start = null;\n                    self.updateContainerPosition().updatePointerPosition(e);\n                    // If the scrollbar was click then don't start\n                    if (opts.scrollbar &&\n                        ((cCoors.scrollX && pCoors.start.x > (cCoors.x + cCoors.w - opts.scrollbar) ||\n                            cCoors.scrollY && pCoors.start.y > (cCoors.y + cCoors.h - opts.scrollbar)))) {\n                        started = false;\n                        return;\n                    }\n                    noose.style.display = 'none';\n                    if (opts.start.apply(self, [e, self.coors]) === false) {\n                        started = false;\n                        return;\n                    }\n                    element.appendChild(noose);\n                }\n            };\n            self._onMove = function (e) {\n                if (opts.enabled) {\n                    if (started && e.currentTarget === self.currentTarget) {\n                        e.cancelable && e.preventDefault();\n                        if (e.type !== 'scroll') {\n                            self.updatePointerPosition(e);\n                        }\n                        self.updateContainerPosition().updateNoosePosition();\n                        // Draw noose\n                        let nTop = self.coors.noose.top;\n                        let nBottom = self.coors.noose.bottom;\n                        noose.style.left = nTop.x + 'px';\n                        noose.style.top = nTop.y + 'px';\n                        noose.style.width = (nBottom.x - nTop.x) + 'px';\n                        noose.style.height = (nBottom.y - nTop.y) + 'px';\n                        noose.style.display = 'block';\n\n                        // Scroll container\n                        let element = self.currentTarget;\n                        let cCoors = self.coors.container;\n                        let pEnd = self.coors.pointer.end;\n                        if (cCoors.scrollY && (pEnd.y - cCoors.y < opts.scrollEdge))\n                            element.scrollTop -= opts.scroll;\n                        else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && (cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge))\n                            element.scrollTop += opts.scroll;\n                        else if (cCoors.scrollX && (pEnd.x - cCoors.x < opts.scrollEdge))\n                            element.scrollLeft -= opts.scroll;\n                        else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && (cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge))\n                            element.scrollLeft += opts.scroll;\n\n                        // Compute selection\n                        if (opts.throttle) {\n                            // Throttle calls to compute\n                            if (!throttled) {\n                                throttled = true;\n                                setTimeout(function () {\n                                    self.compute();\n                                    throttled = false;\n                                }, opts.throttle);\n                            }\n                        } else {\n                            self.compute();\n                        }\n                    }\n                }\n            };\n            self._onEnd = function (e) {\n                if (self.opts.enabled &&\n                    started &&\n                    (e.type !== 'mouseup' || e.which === 1)) {\n                    started = false;\n                    if (e.currentTarget === self.currentTarget) {\n                        self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n                        self.compute();\n                        setTimeout(function () {\n                            opts.stop.apply(self, [e, self.coors, self.selected]);\n                        }, 0);\n                        self.currentTarget.removeChild(noose);\n                    }\n                }\n            };\n            // Register handlers\n            Array.prototype.forEach.call(self.containers, function (container) {\n                // Fixing chrome mobile touch event issue\n                // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n                container.addEventListener('mousedown', self._onStart);\n                container.addEventListener('touchstart', self._onStart, false);\n                container.addEventListener('mousemove', self._onMove);\n                container.addEventListener('touchmove', self._onMove, false);\n                container.addEventListener('scroll', self._onMove);\n                container.addEventListener('mouseup', self._onEnd);\n                container.addEventListener('touchend', self._onEnd, false);\n\n                container.noose = self;\n            });\n\n            return self;\n        }\n        /**\n         * Destroy this Noose instance.\n         *\n         * @returns {Noose} This instance.\n         */\n        destroy() {\n            const self = this;\n            self.containers.forEach(function (container) {\n                container.removeEventListener('mousedown', self._onStart);\n                container.removeEventListener('touchstart', self._onStart);\n                container.removeEventListener('mousemove', self._onMove);\n                container.removeEventListener('touchmove', self._onMove);\n                container.removeEventListener('scroll', self._onMove);\n                container.removeEventListener('mouseup', self._onEnd);\n                container.removeEventListener('touchend', self._onEnd);\n\n                delete container.noose;\n            });\n\n            return self;\n        }\n        /**\n         * Update the current container's position.\n         * \n         * @returns {Noose} This instance.\n         */\n        updateContainerPosition() {\n            const cCoors = this.coors.container;\n            const rect = this.currentTarget.getBoundingClientRect();\n            // Get position relative to the document's top left origin\n            cCoors.x = rect.left + window.pageXOffset;\n            cCoors.y = rect.top + window.pageYOffset;\n            cCoors.w = rect.width;\n            cCoors.h = rect.height;\n\n            return this;\n        }\n        /**\n         * Update the current pointer (mouse/touch) position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updatePointerPosition(e) {\n            const root = e && e.touches && e.touches[0] || e;\n            const pCoors = this.coors.pointer;\n\n            if (root && typeof root.pageX === 'number') {\n                // Get position relative to the document's top left origin\n\n                // Current position is always end\n                pCoors.end = {\n                    x: root.pageX,\n                    y: root.pageY\n                };\n                // Keep start static\n                if (!pCoors.start) {\n                    pCoors.start = pCoors.end;\n                }\n            }\n\n            return this;\n        }\n        /**\n         * Updates the noose top/bottom position.\n         *\n         * @returns {Noose} This instance.\n         */\n        updateNoosePosition() {\n            const element = this.currentTarget;\n            const pCoors = this.coors.pointer;\n            const cCoors = this.coors.container;\n            const nCoors = this.coors.noose;\n            // Pointer and container are both relative to document top left origin.\n            // The noose is positioned absolute relative to the container. So that's\n            // (pointer - container), and also account for the container's scroll position.\n            const endX = Math.max(pCoors.end.x - cCoors.x + element.scrollLeft, 0);\n            const endY = Math.max(pCoors.end.y - cCoors.y + element.scrollTop, 0);\n\n            if (!nCoors.start) {\n                // Keep start position static\n                nCoors.start = {\n                    x: endX,\n                    y: endY\n                };\n            }\n\n            // Determine top and bottom of the noose\n            // top < bottom\n            nCoors.top = {\n                x: Math.min(nCoors.start.x, endX),\n                y: Math.min(nCoors.start.y, endY)\n            };\n            nCoors.bottom = {\n                x: Math.min(Math.max(nCoors.start.x, endX), element.scrollWidth),\n                y: Math.min(Math.max(nCoors.start.y, endY), element.scrollHeight)\n            };\n\n            return this;\n        }\n        /**\n         * Compute the selected elements within the noose region.\n         *\n         * @returns {Noose} This instance.\n         */\n        compute() {\n            const self = this;\n            // Only do if select is enabled\n            if (self.opts.select) {\n                const className = self.opts.classes.selected;\n                const elements = self.currentTarget.querySelectorAll(self.opts.select);\n                const nTop = self.coors.noose.top;\n                const nBottom = self.coors.noose.bottom;\n                const offsetX = self.coors.container.x;\n                const offsetY = self.coors.container.y;\n                self.selected = [];\n                Array.prototype.forEach.call(elements, function (element) {\n                    if (element === self.noose)\n                        return; // Don't include noose\n                    let include = false;\n                    // Get absolute position of element relative to container\n                    const rect = element.getBoundingClientRect();\n                    const topX = rect.left + window.pageXOffset - offsetX + self.currentTarget.scrollLeft;\n                    const topY = rect.top + window.pageYOffset - offsetY + self.currentTarget.scrollTop;\n                    const bottomX = rect.width + topX;\n                    const bottomY = rect.height + topY;\n                    if (self.opts.mode === 'fit') {\n                        // Include is entire element is within noose\n                        include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\n                    } else {\n                        // Include if partially touching\n                        include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\n                    }\n                    if (include) {\n                        className && element.classList.add(className);\n                        self.selected.push(element);\n                    } else {\n                        className && element.classList.remove(className);\n                    }\n                });\n            }\n\n            return self;\n        }\n        /**\n         * Get the current version.\n         */\n        static get version() {\n            return '1.0.0';\n        }\n    }\n\n    return Noose;\n}, window, document));\n"]}