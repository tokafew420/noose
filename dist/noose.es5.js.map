{"version":3,"file":"noose.es5.js","names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_typeof","obj","Symbol","iterator","constructor","factory","window","document","exports","module","define","amd","Noose","noop","_min","Math","min","_max","max","_unit","defaults","classes","noose","selected","compute","container","containers","ctrl","detach","enabled","mode","move","scroll","scrollEdge","scrollbar","select","shift","start","stop","style","border","zIndex","throttle","opts","this","self","HTMLElement","assign","Error","Array","slice","call","querySelectorAll","coors","pointer","createElement","position","classList","add","started","throttled","_onStart","e","sameContainer","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","pStart","pEnd","end","updateContainerPosition","updatePointerPosition","x","w","y","h","shiftKey","nTop","top","nBottom","bottom","midX","floor","midY","ctrlKey","lastSelection","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","_onEnd","removeChild","forEach","_register","value","_deregister","remove","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","endY","className","elements","offsetX","offsetY","include","topX","topY","bottomX","bottomY","idx","indexOf","push","removeEventListener","splice","addEventListener","get"],"sources":["noose.es5.js"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/**\r\n * Noose\r\n * \r\n * version: 1.2.3\r\n */\n(function (factory, window, document) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // CommonJS\n    module.exports = factory(window, document);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(function () {\n      return factory(window, document);\n    });\n  } else {\n    window.Noose = factory(window, document);\n  }\n})(function (window, document) {\n  'use strict';\n\n  function noop() {}\n\n  var _min = Math.min;\n  var _max = Math.max;\n  var _unit = 'px'; // Default options\n\n  var defaults = {\n    // Classes for styling\n    classes: {\n      noose: 'noose',\n      selected: 'selected'\n    },\n    // Enable/disable computing of selected elements\n    compute: true,\n    // Containing element for the noose\n    container: 'body',\n    // Array of containers registered on this instance.\n    containers: [],\n    // Enable/disable support for ctrl key\n    ctrl: true,\n    // Whether to detach the noose from the container after noosing\n    detach: true,\n    // Whether the noose is enabled\n    enabled: true,\n    // The selection mode, part or whole\n    mode: 'touch',\n    // On noose move\n    move: noop,\n    // The amount of pixels to scroll\n    scroll: 10,\n    // The edge offset when scrolling should happen\n    scrollEdge: 10,\n    // The scrollbar size\n    scrollbar: 17,\n    // Elements to select\n    select: '*',\n    // Enabled/disable support for shift key\n    shift: true,\n    // On noose-ing start handler\n    start: noop,\n    // On noose-ing stop handler\n    stop: noop,\n    // Styles for the noose\n    style: {\n      border: '1px dotted #000',\n      zIndex: 1000\n    },\n    // Throttle calls to compute selection\n    throttle: 200\n  };\n\n  var Noose = /*#__PURE__*/function () {\n    function Noose(container, opts) {\n      _classCallCheck(this, Noose);\n\n      var self = this; // Parse arguments\n\n      if (_typeof(container) === 'object' && container != null && !(container instanceof HTMLElement)) {\n        opts = container;\n        container = null;\n      }\n\n      opts = self.opts = Object.assign({}, defaults, opts); // Container must be positioned (anything but static)\n\n      if (typeof container === 'string' || container instanceof HTMLElement) {\n        opts.container = container;\n      } // Get containers\n\n\n      if (opts.container instanceof HTMLElement) {\n        self.containers = [opts.container];\n      } else if (typeof opts.container === 'string') {\n        self.containers = Array.prototype.slice.call(document.querySelectorAll(opts.container));\n      } else {\n        throw new Error('Invalid container option');\n      } // Setup states\n\n\n      self.coors = {\n        // Relative to document top left origin\n        pointer: {},\n        // Relative to container\n        noose: {},\n        // Relative to document top left origin\n        container: {}\n      }; // Create noose\n\n      var noose = self.noose = document.createElement('div');\n      noose.style.position = 'absolute';\n      noose.style.zIndex = opts.style.zIndex;\n      noose.style.border = opts.style.border;\n\n      if (opts.classes.noose) {\n        noose.classList.add(opts.classes.noose);\n      }\n\n      var started = false; // Flag for noose-ing started\n\n      var throttled = false;\n\n      self._onStart = function (e) {\n        var sameContainer = e.currentTarget === self.currentTarget;\n\n        if (opts.enabled && (!started || !sameContainer) && (e.type !== 'mousedown' || e.which === 1)) {\n          started = true;\n          var element = self.currentTarget = e.currentTarget;\n          var cCoors = self.coors.container;\n          var pCoors = self.coors.pointer;\n          var nCoors = self.coors.noose; // Initialize container values\n\n          var style = window.getComputedStyle(element);\n\n          if (style.position === 'static') {\n            console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n          } // Does the container have scrollbars\n\n\n          if (opts.scroll > 0 && opts.scrollEdge > 0) {\n            cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\n            cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\n          } else {\n            cCoors.scrollX = false;\n            cCoors.scrollY = false;\n          } // Set the max allowed scroll amount\n\n\n          cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\n          cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0; // Get previous start coors in case we need to restore them\n\n          var pStart = pCoors.start;\n          var pEnd = pCoors.end; // Reset start positions\n\n          pCoors.start = null;\n          nCoors.start = null;\n          self.updateContainerPosition().updatePointerPosition(e); // If the scrollbar was click then don't start\n\n          if (opts.scrollbar && (cCoors.scrollX && pCoors.end.x > cCoors.x + cCoors.w - opts.scrollbar || cCoors.scrollY && pCoors.end.y > cCoors.y + cCoors.h - opts.scrollbar)) {\n            started = false;\n            pCoors.start = pStart;\n            pCoors.end = pEnd;\n            return;\n          } // Shift key is pressed, continue noose from previous opposing corner\n\n\n          if (opts.shift && sameContainer && e.shiftKey && pStart) {\n            var nTop = nCoors.top;\n            var nBottom = nCoors.bottom;\n            var midX = Math.floor((pStart.x + pEnd.x) / 2);\n            var midY = Math.floor((pStart.y + pEnd.y) / 2);\n            nCoors.start = {};\n\n            if (pCoors.start.x >= midX && pCoors.start.y < midY) {\n              // 1st quadrant\n              pCoors.start.x = _min(pStart.x, pEnd.x);\n              pCoors.start.y = _max(pStart.y, pEnd.y);\n              nCoors.start.x = nTop.x;\n              nCoors.start.y = nBottom.y;\n            } else if (pCoors.start.x < midX && pCoors.start.y <= midY) {\n              // 2nd quadrant\n              pCoors.start.x = _max(pStart.x, pEnd.x);\n              pCoors.start.y = _max(pStart.y, pEnd.y);\n              nCoors.start = nBottom;\n            } else if (pCoors.start.x <= midX && pCoors.start.y > midY) {\n              // 3rd quadrant\n              pCoors.start.x = _max(pStart.x, pEnd.x);\n              pCoors.start.y = _min(pStart.y, pEnd.y);\n              nCoors.start.x = nBottom.x;\n              nCoors.start.y = nTop.y;\n            } else if (pCoors.start.x > midX && pCoors.start.y >= midY) {\n              // 4th quadrant\n              pCoors.start.x = _min(pStart.x, pEnd.x);\n              pCoors.start.y = _min(pStart.y, pEnd.y);\n              nCoors.start = nTop;\n            }\n          }\n\n          if (opts.ctrl && sameContainer && e.ctrlKey) {\n            self.lastSelection = self.selected || [];\n          } else {\n            self.lastSelection = [];\n          }\n\n          noose.style.display = 'none';\n\n          if (opts.start.apply(self, [e, self.coors]) === false) {\n            started = false;\n            pCoors.start = pStart;\n            pCoors.end = pEnd;\n            return;\n          }\n\n          element.appendChild(noose);\n        }\n      };\n\n      self._onMove = function (e) {\n        if (opts.enabled) {\n          if (started && e.currentTarget === self.currentTarget) {\n            e.cancelable && e.preventDefault();\n\n            if (e.type !== 'scroll') {\n              self.updatePointerPosition(e);\n            }\n\n            self.updateContainerPosition().updateNoosePosition(); // Draw noose\n\n            var nTop = self.coors.noose.top;\n            var nBottom = self.coors.noose.bottom;\n            noose.style.left = nTop.x + _unit;\n            noose.style.top = nTop.y + _unit;\n            noose.style.width = nBottom.x - nTop.x + _unit;\n            noose.style.height = nBottom.y - nTop.y + _unit;\n            noose.style.display = 'block'; // Scroll container\n\n            var element = self.currentTarget;\n            var cCoors = self.coors.container;\n            var pEnd = self.coors.pointer.end;\n            if (cCoors.scrollY && pEnd.y - cCoors.y < opts.scrollEdge) element.scrollTop -= opts.scroll;else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge) element.scrollTop += opts.scroll;else if (cCoors.scrollX && pEnd.x - cCoors.x < opts.scrollEdge) element.scrollLeft -= opts.scroll;else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge) element.scrollLeft += opts.scroll;\n\n            if (opts.compute) {\n              // Compute selection\n              if (opts.throttle) {\n                // Throttle calls to compute\n                if (!throttled) {\n                  throttled = true;\n                  setTimeout(function () {\n                    throttled && self.compute() && opts.move.apply(self, [e, self.coors, self.selected]);\n                    throttled = false;\n                  }, opts.throttle);\n                }\n              } else {\n                self.compute();\n                opts.move.apply(self, [e, self.coors, self.selected]);\n              }\n            }\n          }\n        }\n      };\n\n      self._onEnd = function (e) {\n        if (self.opts.enabled && started && (e.type !== 'mouseup' || e.which === 1)) {\n          started = false;\n\n          if (e.currentTarget === self.currentTarget) {\n            self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n            throttled = false; // Don't run throttled compute after noose action already completed\n\n            opts.compute && self.compute(true);\n            setTimeout(function () {\n              opts.stop.apply(self, [e, self.coors, self.selected]);\n            }, 0);\n            if (opts.detach) self.currentTarget.removeChild(noose);\n          }\n        }\n      }; // Register handlers\n\n\n      self.containers.forEach(function (container) {\n        self._register(container);\n      });\n      return self;\n    }\n    /**\r\n     * Destroy this Noose instance.\r\n     *\r\n     * @returns {Noose} This instance.\r\n     */\n\n\n    _createClass(Noose, [{\n      key: \"destroy\",\n      value: function destroy() {\n        var self = this;\n        self.containers.forEach(function (container) {\n          self._deregister(container);\n        });\n        self.noose.remove();\n        self.noose = null;\n        return self;\n      }\n      /**\r\n       * Update the current container's position.\r\n       * \r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"updateContainerPosition\",\n      value: function updateContainerPosition() {\n        var cCoors = this.coors.container;\n        var rect = this.currentTarget.getBoundingClientRect(); // Get position relative to the document's top left origin\n\n        cCoors.x = rect.left + window.pageXOffset;\n        cCoors.y = rect.top + window.pageYOffset;\n        cCoors.w = rect.width;\n        cCoors.h = rect.height;\n        return this;\n      }\n      /**\r\n       * Update the current pointer (mouse/touch) position.\r\n       *\r\n       * @param {Event} e The event that prompted recalculation of the noose (ie: mousemove, touchmove, or scroll).\r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"updatePointerPosition\",\n      value: function updatePointerPosition(e) {\n        var root = e && e.touches && e.touches[0] || e;\n        var pCoors = this.coors.pointer;\n\n        if (root && typeof root.pageX === 'number') {\n          // Get position relative to the document's top left origin\n          // Current position is always end\n          pCoors.end = {\n            x: root.pageX,\n            y: root.pageY\n          }; // Keep start static\n\n          if (!pCoors.start) {\n            pCoors.start = pCoors.end;\n          }\n        }\n\n        return this;\n      }\n      /**\r\n       * Updates the noose top/bottom position.\r\n       *\r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"updateNoosePosition\",\n      value: function updateNoosePosition() {\n        var element = this.currentTarget;\n        var pEnd = this.coors.pointer.end;\n        var cCoors = this.coors.container;\n        var nCoors = this.coors.noose; // Pointer and container are both relative to document top left origin.\n        // The noose is positioned absolute relative to the container. So that's\n        // (pointer - container), and also account for the container's scroll position.\n\n        var endX = _max(pEnd.x - cCoors.x + element.scrollLeft, 0);\n\n        var endY = _max(pEnd.y - cCoors.y + element.scrollTop, 0);\n\n        if (!nCoors.start) {\n          // Keep start position static\n          nCoors.start = {\n            x: endX,\n            y: endY\n          };\n        } // Determine top and bottom of the noose\n        // top < bottom\n\n\n        nCoors.top = {\n          x: _min(nCoors.start.x, endX),\n          y: _min(nCoors.start.y, endY)\n        };\n        nCoors.bottom = {\n          x: _min(_max(nCoors.start.x, endX), element.scrollWidth),\n          y: _min(_max(nCoors.start.y, endY), element.scrollHeight)\n        };\n        return this;\n      }\n      /**\r\n       * Compute the selected elements within the noose region.\r\n       *\r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"compute\",\n      value: function compute() {\n        var self = this; // Only do if select is enabled\n\n        if (self.opts.select) {\n          var className = self.opts.classes.selected;\n          var container = self.currentTarget;\n          var elements = container.querySelectorAll(self.opts.select);\n          var nTop = self.coors.noose.top;\n          var nBottom = self.coors.noose.bottom;\n          var offsetX = self.coors.container.x;\n          var offsetY = self.coors.container.y;\n          self.selected = [];\n          Array.prototype.forEach.call(elements, function (element) {\n            if (element === self.noose) return; // Don't include noose\n\n            var include; // Get absolute position of element relative to container\n\n            var rect = element.getBoundingClientRect();\n            var topX = rect.left + window.pageXOffset - offsetX + container.scrollLeft;\n            var topY = rect.top + window.pageYOffset - offsetY + container.scrollTop;\n            var bottomX = rect.width + topX;\n            var bottomY = rect.height + topY;\n\n            if (self.opts.mode === 'fit') {\n              // Include if entire element is within noose\n              include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\n            } else {\n              // Include if partially touching\n              include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\n            }\n\n            var idx = self.lastSelection.indexOf(element);\n\n            if (include && idx === -1 || !include && idx !== -1) {\n              className && element.classList.add(className);\n              self.selected.push(element);\n            } else {\n              className && element.classList.remove(className);\n            }\n          });\n        }\n\n        return self;\n      }\n    }, {\n      key: \"_deregister\",\n      value: function _deregister(container) {\n        container.removeEventListener('mousedown', this._onStart);\n        container.removeEventListener('touchstart', this._onStart);\n        container.removeEventListener('mousemove', this._onMove);\n        container.removeEventListener('touchmove', this._onMove);\n        container.removeEventListener('scroll', this._onMove);\n        container.removeEventListener('mouseup', this._onEnd);\n        container.removeEventListener('touchend', this._onEnd);\n        delete container.noose;\n        return this;\n      }\n      /**\r\n       * Deregister a container from the Noose instance.\r\n       * \r\n       * @param {HTMLElement} container The container to remove.\r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"deregister\",\n      value: function deregister(container) {\n        var idx = this.containers.indexOf(container);\n\n        if (idx > -1 && typeof container.removeEventListener === 'function') {\n          this._deregister(container);\n\n          this.containers.splice(idx, 1);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"_register\",\n      value: function _register(container) {\n        // Fixing chrome mobile touch event issue\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        container.addEventListener('mousedown', this._onStart);\n        container.addEventListener('touchstart', this._onStart, false);\n        container.addEventListener('mousemove', this._onMove);\n        container.addEventListener('touchmove', this._onMove, false);\n        container.addEventListener('scroll', this._onMove);\n        container.addEventListener('mouseup', this._onEnd);\n        container.addEventListener('touchend', this._onEnd, false);\n        return container.noose = this;\n      }\n      /**\r\n       * Register a container to the Noose instance.\r\n       * \r\n       * @param {HTMLElement} container The container to register.\r\n       * @returns {Noose} This instance.\r\n       */\n\n    }, {\n      key: \"register\",\n      value: function register(container) {\n        var idx = this.containers.indexOf(container);\n\n        if (idx === -1 && typeof container.addEventListener === 'function') {\n          this._register(container);\n\n          this.containers.push(container);\n        }\n\n        return this;\n      }\n      /**\r\n       * Get the current version.\r\n       */\n\n    }], [{\n      key: \"version\",\n      get: function get() {\n        return '1.2.3';\n      }\n    }]);\n\n    return Noose;\n  }();\n\n  return Noose;\n}, window, document);"]}