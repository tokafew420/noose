{"version":3,"sources":["noose.es5.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_typeof","obj","Symbol","iterator","constructor","factory","window","document","exports","module","define","amd","Noose","noop","defaults","classes","noose","selected","compute","container","enabled","mode","scroll","scrollEdge","scrollbar","select","start","stop","style","border","zIndex","throttle","opts","this","self","HTMLElement","assign","containers","Error","querySelectorAll","coors","pointer","end","top","bottom","createElement","position","classList","add","started","throttled","_onStart","e","currentTarget","type","which","element","cCoors","pCoors","nCoors","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","updateContainerPosition","updatePointerPosition","x","w","y","h","display","apply","appendChild","_onMove","cancelable","preventDefault","updateNoosePosition","nTop","nBottom","left","width","height","pEnd","scrollTop","scrollLeft","setTimeout","_onEnd","removeChild","Array","forEach","call","addEventListener","value","removeEventListener","remove","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pageY","endX","Math","max","endY","min","className","elements","offsetX","offsetY","topX","topY","bottomX","bottomY","push","get"],"mappings":"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","file":"noose.es5.js","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Noose\n * \n * version: 1.1.5\n */\n(function (factory, window, document) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // CommonJS\n    module.exports = factory(window, document);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(function () {\n      return factory(window, document);\n    });\n  } else {\n    window.Noose = factory(window, document);\n  }\n})(function (window, document) {\n  'use strict';\n\n  function noop() {} // Default options\n\n\n  var defaults = {\n    // Classes for styling\n    classes: {\n      noose: 'noose',\n      selected: 'selected'\n    },\n    // Enable/disable computing of selected elements\n    compute: true,\n    // Containing element for the noose\n    container: 'body',\n    // Whether the noose is enabled\n    enabled: true,\n    // The selection mode, part or whole\n    mode: 'touch',\n    // The amount of pixels to scroll\n    scroll: 10,\n    // The edge offset when scrolling should happen\n    scrollEdge: 10,\n    // The scrollbar size\n    scrollbar: 17,\n    // Elements to select\n    select: '*',\n    // On noose-ing start handler\n    start: noop,\n    // On noose-ing stop handler\n    stop: noop,\n    // Styles for the noose\n    style: {\n      border: '1px dotted #000',\n      zIndex: 1000\n    },\n    // Throttle calls to compute selection\n    throttle: 200\n  };\n\n  var Noose =\n  /*#__PURE__*/\n  function () {\n    function Noose(container, opts) {\n      _classCallCheck(this, Noose);\n\n      var self = this; // Parse arguments\n\n      if (_typeof(container) === 'object' && container != null && !(container instanceof HTMLElement)) {\n        opts = container;\n        container = null;\n      }\n\n      opts = self.opts = Object.assign({}, defaults, opts); // Container must be positioned (anything but static)\n\n      if (typeof container === 'string' || container instanceof HTMLElement) {\n        opts.container = container;\n      } // Get containers\n\n\n      if (opts.container instanceof HTMLElement) {\n        self.containers = [opts.container];\n      } else if (typeof opts.container === 'string') {\n        self.containers = document.querySelectorAll(opts.container);\n      } else {\n        throw new Error('Invalid container option');\n      } // Setup states\n\n\n      self.coors = {\n        // Relative to document top left origin\n        pointer: {\n          start: null,\n          end: {} // The current/end position of the mouse/touch\n\n        },\n        // Relative to container\n        noose: {\n          top: null,\n          bottom: null // The bottom right position of the noose\n\n        },\n        // Relative to document top left origin\n        container: {}\n      }; // Create noose\n\n      var noose = self.noose = document.createElement('div');\n      noose.style.position = 'absolute';\n      noose.style.zIndex = opts.style.zIndex;\n      noose.style.border = opts.style.border;\n\n      if (opts.classes.noose) {\n        noose.classList.add(opts.classes.noose);\n      }\n\n      var started = false; // Flag for noose-ing started\n\n      var throttled = false;\n\n      self._onStart = function (e) {\n        if (opts.enabled && (!started || e.currentTarget !== self.currentTarget) && (e.type !== 'mousedown' || e.which === 1)) {\n          started = true;\n          var element = self.currentTarget = e.currentTarget;\n          var cCoors = self.coors.container;\n          var pCoors = self.coors.pointer;\n          var nCoors = self.coors.noose; // Initialize container values\n\n          var style = window.getComputedStyle(element);\n\n          if (style.position === 'static') {\n            console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n          } // Does the container have scrollbars\n\n\n          if (opts.scroll > 0 && opts.scrollEdge > 0) {\n            cCoors.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && element.scrollHeight > element.clientHeight;\n            cCoors.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && element.scrollWidth > element.clientWidth;\n          } else {\n            cCoors.scrollX = false;\n            cCoors.scrollY = false;\n          } // Set the max allowed scroll amount\n\n\n          cCoors.maxScrollY = cCoors.scrollY && element.scrollHeight - element.clientHeight || 0;\n          cCoors.maxScrollX = cCoors.scrollX && element.scrollWidth - element.clientWidth || 0; // Reset start positions\n\n          pCoors.start = null;\n          nCoors.start = null;\n          self.updateContainerPosition().updatePointerPosition(e); // If the scrollbar was click then don't start\n\n          if (opts.scrollbar && (cCoors.scrollX && pCoors.start.x > cCoors.x + cCoors.w - opts.scrollbar || cCoors.scrollY && pCoors.start.y > cCoors.y + cCoors.h - opts.scrollbar)) {\n            started = false;\n            return;\n          }\n\n          noose.style.display = 'none';\n\n          if (opts.start.apply(self, [e, self.coors]) === false) {\n            started = false;\n            return;\n          }\n\n          element.appendChild(noose);\n        }\n      };\n\n      self._onMove = function (e) {\n        if (opts.enabled) {\n          if (started && e.currentTarget === self.currentTarget) {\n            e.cancelable && e.preventDefault();\n\n            if (e.type !== 'scroll') {\n              self.updatePointerPosition(e);\n            }\n\n            self.updateContainerPosition().updateNoosePosition(); // Draw noose\n\n            var nTop = self.coors.noose.top;\n            var nBottom = self.coors.noose.bottom;\n            noose.style.left = nTop.x + 'px';\n            noose.style.top = nTop.y + 'px';\n            noose.style.width = nBottom.x - nTop.x + 'px';\n            noose.style.height = nBottom.y - nTop.y + 'px';\n            noose.style.display = 'block'; // Scroll container\n\n            var element = self.currentTarget;\n            var cCoors = self.coors.container;\n            var pEnd = self.coors.pointer.end;\n            if (cCoors.scrollY && pEnd.y - cCoors.y < opts.scrollEdge) element.scrollTop -= opts.scroll;else if (cCoors.scrollY && element.scrollTop < cCoors.maxScrollY && cCoors.y + cCoors.h - pEnd.y < opts.scrollEdge) element.scrollTop += opts.scroll;else if (cCoors.scrollX && pEnd.x - cCoors.x < opts.scrollEdge) element.scrollLeft -= opts.scroll;else if (cCoors.scrollX && element.scrollLeft < cCoors.maxScrollX && cCoors.x + cCoors.w - pEnd.x < opts.scrollEdge) element.scrollLeft += opts.scroll;\n\n            if (opts.compute) {\n              // Compute selection\n              if (opts.throttle) {\n                // Throttle calls to compute\n                if (!throttled) {\n                  throttled = true;\n                  setTimeout(function () {\n                    self.compute();\n                    throttled = false;\n                  }, opts.throttle);\n                }\n              } else {\n                self.compute();\n              }\n            }\n          }\n        }\n      };\n\n      self._onEnd = function (e) {\n        if (self.opts.enabled && started && (e.type !== 'mouseup' || e.which === 1)) {\n          started = false;\n\n          if (e.currentTarget === self.currentTarget) {\n            self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n            opts.compute && self.compute();\n            setTimeout(function () {\n              opts.stop.apply(self, [e, self.coors, self.selected]);\n            }, 0);\n            self.currentTarget.removeChild(noose);\n          }\n        }\n      }; // Register handlers\n\n\n      Array.prototype.forEach.call(self.containers, function (container) {\n        // Fixing chrome mobile touch event issue\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        container.addEventListener('mousedown', self._onStart);\n        container.addEventListener('touchstart', self._onStart, false);\n        container.addEventListener('mousemove', self._onMove);\n        container.addEventListener('touchmove', self._onMove, false);\n        container.addEventListener('scroll', self._onMove);\n        container.addEventListener('mouseup', self._onEnd);\n        container.addEventListener('touchend', self._onEnd, false);\n        container.noose = self;\n      });\n      return self;\n    }\n    /**\n     * Destroy this Noose instance.\n     *\n     * @returns {Noose} This instance.\n     */\n\n\n    _createClass(Noose, [{\n      key: \"destroy\",\n      value: function destroy() {\n        var self = this;\n        self.containers.forEach(function (container) {\n          container.removeEventListener('mousedown', self._onStart);\n          container.removeEventListener('touchstart', self._onStart);\n          container.removeEventListener('mousemove', self._onMove);\n          container.removeEventListener('touchmove', self._onMove);\n          container.removeEventListener('scroll', self._onMove);\n          container.removeEventListener('mouseup', self._onEnd);\n          container.removeEventListener('touchend', self._onEnd);\n          delete container.noose;\n        });\n        self.noose.remove();\n        self.noose = null;\n        return self;\n      }\n      /**\n       * Update the current container's position.\n       * \n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updateContainerPosition\",\n      value: function updateContainerPosition() {\n        var cCoors = this.coors.container;\n        var rect = this.currentTarget.getBoundingClientRect(); // Get position relative to the document's top left origin\n\n        cCoors.x = rect.left + window.pageXOffset;\n        cCoors.y = rect.top + window.pageYOffset;\n        cCoors.w = rect.width;\n        cCoors.h = rect.height;\n        return this;\n      }\n      /**\n       * Update the current pointer (mouse/touch) position.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updatePointerPosition\",\n      value: function updatePointerPosition(e) {\n        var root = e && e.touches && e.touches[0] || e;\n        var pCoors = this.coors.pointer;\n\n        if (root && typeof root.pageX === 'number') {\n          // Get position relative to the document's top left origin\n          // Current position is always end\n          pCoors.end = {\n            x: root.pageX,\n            y: root.pageY\n          }; // Keep start static\n\n          if (!pCoors.start) {\n            pCoors.start = pCoors.end;\n          }\n        }\n\n        return this;\n      }\n      /**\n       * Updates the noose top/bottom position.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updateNoosePosition\",\n      value: function updateNoosePosition() {\n        var element = this.currentTarget;\n        var pCoors = this.coors.pointer;\n        var cCoors = this.coors.container;\n        var nCoors = this.coors.noose; // Pointer and container are both relative to document top left origin.\n        // The noose is positioned absolute relative to the container. So that's\n        // (pointer - container), and also account for the container's scroll position.\n\n        var endX = Math.max(pCoors.end.x - cCoors.x + element.scrollLeft, 0);\n        var endY = Math.max(pCoors.end.y - cCoors.y + element.scrollTop, 0);\n\n        if (!nCoors.start) {\n          // Keep start position static\n          nCoors.start = {\n            x: endX,\n            y: endY\n          };\n        } // Determine top and bottom of the noose\n        // top < bottom\n\n\n        nCoors.top = {\n          x: Math.min(nCoors.start.x, endX),\n          y: Math.min(nCoors.start.y, endY)\n        };\n        nCoors.bottom = {\n          x: Math.min(Math.max(nCoors.start.x, endX), element.scrollWidth),\n          y: Math.min(Math.max(nCoors.start.y, endY), element.scrollHeight)\n        };\n        return this;\n      }\n      /**\n       * Compute the selected elements within the noose region.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"compute\",\n      value: function compute() {\n        var self = this; // Only do if select is enabled\n\n        if (self.opts.select) {\n          var className = self.opts.classes.selected;\n          var elements = self.currentTarget.querySelectorAll(self.opts.select);\n          var nTop = self.coors.noose.top;\n          var nBottom = self.coors.noose.bottom;\n          var offsetX = self.coors.container.x;\n          var offsetY = self.coors.container.y;\n          self.selected = [];\n          Array.prototype.forEach.call(elements, function (element) {\n            if (element === self.noose) return; // Don't include noose\n\n            var include = false; // Get absolute position of element relative to container\n\n            var rect = element.getBoundingClientRect();\n            var topX = rect.left + window.pageXOffset - offsetX + self.currentTarget.scrollLeft;\n            var topY = rect.top + window.pageYOffset - offsetY + self.currentTarget.scrollTop;\n            var bottomX = rect.width + topX;\n            var bottomY = rect.height + topY;\n\n            if (self.opts.mode === 'fit') {\n              // Include is entire element is within noose\n              include = nTop.x <= topX && nTop.y <= topY && nBottom.x >= bottomX && nBottom.y >= bottomY;\n            } else {\n              // Include if partially touching\n              include = !(nTop.x > bottomX || nTop.y > bottomY || nBottom.x < topX || nBottom.y < topY);\n            }\n\n            if (include) {\n              className && element.classList.add(className);\n              self.selected.push(element);\n            } else {\n              className && element.classList.remove(className);\n            }\n          });\n        }\n\n        return self;\n      }\n      /**\n       * Get the current version.\n       */\n\n    }], [{\n      key: \"version\",\n      get: function get() {\n        return '1.1.5';\n      }\n    }]);\n\n    return Noose;\n  }();\n\n  return Noose;\n}, window, document);"]}