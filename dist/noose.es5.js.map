{"version":3,"sources":["noose.es5.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_typeof","obj","Symbol","iterator","constructor","factory","window","document","exports","module","define","amd","Noose","noop","defaults","container","classes","noose","selected","enabled","mode","scroll","scrollEdge","scrollbar","select","start","stop","style","border","zIndex","throttle","opts","this","self","Element","assign","containers","Error","querySelectorAll","coors","pointer","end","top","bottom","createElement","position","classList","add","started","throttled","_onStart","e","currentTarget","type","which","getComputedStyle","console","warn","scrollX","overflowX","scrollHeight","clientHeight","scrollY","overflowY","scrollWidth","clientWidth","maxScrollY","maxScrollX","updateContainerPosition","updatePointerPosition","x","w","y","h","display","apply","defaultPrevented","appendChild","_onMove","preventDefault","updateNoosePosition","left","width","height","scrollTop","scrollLeft","setTimeout","compute","_onEnd","removeChild","Array","forEach","call","addEventListener","value","removeEventListener","containerCoors","rect","getBoundingClientRect","pageXOffset","pageYOffset","root","touches","pageX","pos","pageY","endX","endY","Math","min","max","className","elements","offsetX","offsetY","element","topX","topY","bottomX","bottomY","push","remove","get"],"mappings":"AAAA,aAEA,SAASA,gBAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,qCAEhH,SAASC,kBAAkBC,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,IAE7S,SAASO,aAAad,EAAae,EAAYC,GAAmJ,OAAhID,GAAYb,kBAAkBF,EAAYiB,UAAWF,GAAiBC,GAAad,kBAAkBF,EAAagB,GAAqBhB,EAEzM,SAASkB,QAAQC,GAAwT,OAAtOD,QAArD,mBAAXE,QAAoD,iBAApBA,OAAOC,SAAmC,SAAiBF,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,mBAAXC,QAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOH,UAAY,gBAAkBE,IAAyBA,IAExV,SAAWI,EAASC,EAAQC,GACgD,YAAlD,oBAAZC,QAA0B,YAAcR,QAAQQ,UAE1DC,OAAOD,QAAUH,EAAQC,EAAQC,GACN,mBAAXG,QAAyBA,OAAOC,IAEhDD,QAAO,WACL,OAAOL,EAAQC,EAAQC,MAGzBD,EAAOM,MAAQP,EAAQC,EAAQC,GAVnC,EAYG,SAAUD,EAAQC,GAGnB,SAASM,KAGT,IAAIC,EAAW,CAEbC,UAAW,OAEXC,QAAS,CACPC,MAAO,GACPC,SAAU,YAGZC,SAAS,EAETC,KAAM,QAENC,OAAQ,GAERC,WAAY,GAEZC,UAAW,GAEXC,OAAQ,IAERC,MAAOZ,EAEPa,KAAMb,EAENc,MAAO,CACLC,OAAQ,kBACRC,OAAQ,KAGVC,SAAU,KAsVZ,OAjVA,WACE,SAASlB,EAAMG,EAAWgB,GACxBnD,gBAAgBoD,KAAMpB,GAEtB,IAAIqB,EAAOD,KAcX,GAZ2B,WAAvBhC,QAAQe,IAAwC,MAAbA,GAAuBA,aAAqBmB,UACjFH,EAAOhB,EACPA,EAAY,MAGdgB,EAAOE,EAAKF,KAAOtC,OAAO0C,OAAO,GAAIrB,EAAUiB,IAEtB,iBAAdhB,GAA0BA,aAAqBmB,WACxDH,EAAKhB,UAAYA,GAIfgB,EAAKhB,qBAAqBmB,QAC5BD,EAAKG,WAAa,CAACL,EAAKhB,eACnB,CAAA,GAA8B,iBAAnBgB,EAAKhB,UAGrB,MAAM,IAAIsB,MAAM,4BAFhBJ,EAAKG,WAAa7B,EAAS+B,iBAAiBP,EAAKhB,WAMnDkB,EAAKM,MAAQ,CAEXC,QAAS,CACPf,MAAO,KACPgB,IAAK,MAIPxB,MAAO,CACLyB,IAAK,KACLC,OAAQ,MAIV5B,UAAW,IAGb,IAAIE,EAAQgB,EAAKhB,MAAQV,EAASqC,cAAc,OAChD3B,EAAMU,MAAMkB,SAAW,WACvB5B,EAAMU,MAAME,OAASI,EAAKF,KAAKJ,MAAME,OACrCZ,EAAMU,MAAMC,OAASK,EAAKF,KAAKJ,MAAMC,OAEjCG,EAAKf,QAAQC,OACfA,EAAM6B,UAAUC,IAAId,EAAKF,KAAKf,QAAQC,OAGxC,IAAI+B,GAAU,EAEVC,GAAY,EAiHhB,OA/GAhB,EAAKiB,SAAW,SAAUC,GACxB,GAAIlB,EAAKF,KAAKZ,WAAa6B,GAAWG,EAAEC,gBAAkBnB,EAAKmB,iBAA8B,cAAXD,EAAEE,MAAoC,IAAZF,EAAEG,OAAc,CAC1HN,GAAU,EACVf,EAAKmB,cAAgBD,EAAEC,cAEvB,IAAIzB,EAAQrB,EAAOiD,iBAAiBtB,EAAKmB,eAElB,WAAnBzB,EAAMkB,UACRW,QAAQC,KAAK,iHAGf,IAAI1C,EAAYkB,EAAKM,MAAMxB,UACvByB,EAAUP,EAAKM,MAAMC,QACrBvB,EAAQgB,EAAKM,MAAMtB,MAkBvB,GAhBIgB,EAAKF,KAAKV,OAAS,GAAKY,EAAKF,KAAKT,WAAa,GACjDP,EAAU2C,SAA+B,SAApB/B,EAAMgC,WAA4C,WAApBhC,EAAMgC,YAA2B1B,EAAKmB,cAAcQ,aAAe3B,EAAKmB,cAAcS,aACzI9C,EAAU+C,SAA+B,SAApBnC,EAAMoC,WAA4C,WAApBpC,EAAMoC,YAA2B9B,EAAKmB,cAAcY,YAAc/B,EAAKmB,cAAca,cAExIlD,EAAU2C,SAAU,EACpB3C,EAAU+C,SAAU,GAItB/C,EAAUmD,WAAanD,EAAU+C,SAAW7B,EAAKmB,cAAcQ,aAAe3B,EAAKmB,cAAcS,cAAgB,EACjH9C,EAAUoD,WAAapD,EAAU2C,SAAWzB,EAAKmB,cAAcY,YAAc/B,EAAKmB,cAAca,aAAe,EAE/GzB,EAAQf,MAAQ,KAChBR,EAAMQ,MAAQ,KACdQ,EAAKmC,0BAA0BC,sBAAsBlB,GAEjDlB,EAAKF,KAAKR,YAAcR,EAAU2C,SAAWlB,EAAQf,MAAM6C,EAAIvD,EAAUuD,EAAIvD,EAAUwD,EAAItC,EAAKF,KAAKR,WAAaR,EAAU+C,SAAWtB,EAAQf,MAAM+C,EAAIzD,EAAUyD,EAAIzD,EAAU0D,EAAIxC,EAAKF,KAAKR,WAEjM,YADAyB,GAAU,GAMZ,GAFAf,EAAKhB,MAAMU,MAAM+C,QAAU,QAE0B,IAAjDzC,EAAKF,KAAKN,MAAMkD,MAAM1C,EAAM,CAACkB,EAAGlB,EAAKM,SAAqBY,EAAEyB,iBAE9D,YADA5B,GAAU,GAIZf,EAAKmB,cAAcyB,YAAY5C,EAAKhB,SAIxCgB,EAAK6C,QAAU,SAAU3B,GACvB,GAAIlB,EAAKF,KAAKZ,SACR6B,GAAWG,EAAEC,gBAAkBnB,EAAKmB,cAAe,CACrDD,EAAE4B,iBAEa,WAAX5B,EAAEE,MACJpB,EAAKoC,sBAAsBlB,GAG7BlB,EAAKmC,0BAA0BY,sBAE/B,IAAItC,EAAMT,EAAKM,MAAMtB,MAAMyB,IACvBC,EAASV,EAAKM,MAAMtB,MAAM0B,OAC9BV,EAAKhB,MAAMU,MAAMsD,KAAOvC,EAAI4B,EAAI,KAChCrC,EAAKhB,MAAMU,MAAMe,IAAMA,EAAI8B,EAAI,KAC/BvC,EAAKhB,MAAMU,MAAMuD,MAAQvC,EAAO2B,EAAI5B,EAAI4B,EAAI,KAC5CrC,EAAKhB,MAAMU,MAAMwD,OAASxC,EAAO6B,EAAI9B,EAAI8B,EAAI,KAC7CvC,EAAKhB,MAAMU,MAAM+C,QAAU,QAE3B,IAAI3D,EAAYkB,EAAKM,MAAMxB,UACvByB,EAAUP,EAAKM,MAAMC,QAAQC,IAC7B1B,EAAU+C,SAAWtB,EAAQgC,EAAIzD,EAAUyD,EAAI,GAAIvC,EAAKmB,cAAcgC,WAAanD,EAAKF,KAAKV,OAAgBN,EAAU+C,SAAW7B,EAAKmB,cAAcgC,UAAYrE,EAAUmD,YAAcnD,EAAUyD,EAAIzD,EAAU0D,EAAIjC,EAAQgC,EAAI,GAAIvC,EAAKmB,cAAcgC,WAAanD,EAAKF,KAAKV,OAAgBN,EAAU2C,SAAWlB,EAAQ8B,EAAIvD,EAAUuD,EAAI,GAAIrC,EAAKmB,cAAciC,YAAcpD,EAAKF,KAAKV,OAAgBN,EAAU2C,SAAWzB,EAAKmB,cAAciC,WAAatE,EAAUoD,YAAcpD,EAAUuD,EAAIvD,EAAUwD,EAAI/B,EAAQ8B,EAAI,KAAIrC,EAAKmB,cAAciC,YAAcpD,EAAKF,KAAKV,QAEjjBY,EAAKF,KAAKD,SAEPmB,IACHA,GAAY,EACZqC,YAAW,WACTrD,EAAKsD,UACLtC,GAAY,IACXhB,EAAKF,KAAKD,WAGfG,EAAKsD,YAMbtD,EAAKuD,OAAS,SAAUrC,GAClBlB,EAAKF,KAAKZ,SAAW6B,IAAuB,YAAXG,EAAEE,MAAkC,IAAZF,EAAEG,SAC7DN,GAAU,EAENG,EAAEC,gBAAkBnB,EAAKmB,gBAC3BnB,EAAKmC,0BAA0BC,sBAAsBlB,GAAG6B,sBACxD/C,EAAKsD,UACLD,YAAW,WACTrD,EAAKF,KAAKL,KAAKiD,MAAM1C,EAAM,CAACkB,EAAGlB,EAAKM,MAAON,EAAKf,aAC/C,GACHe,EAAKmB,cAAcqC,YAAYxD,EAAKhB,UAM1CyE,MAAM3F,UAAU4F,QAAQC,KAAK3D,EAAKG,YAAY,SAAUrB,GACtDA,EAAU8E,iBAAiB,YAAa5D,EAAKiB,UAC7CnC,EAAU8E,iBAAiB,aAAc5D,EAAKiB,UAC9CnC,EAAU8E,iBAAiB,YAAa5D,EAAK6C,SAC7C/D,EAAU8E,iBAAiB,YAAa5D,EAAK6C,SAC7C/D,EAAU8E,iBAAiB,SAAU5D,EAAK6C,SAC1C/D,EAAU8E,iBAAiB,UAAW5D,EAAKuD,QAC3CzE,EAAU8E,iBAAiB,WAAY5D,EAAKuD,WAEvCvD,EAsKT,OA7JArC,aAAagB,EAAO,CAAC,CACnBjB,IAAK,UACLmG,MAAO,WACL,IAAI7D,EAAOD,KAUX,OATAC,EAAKG,WAAWuD,SAAQ,SAAU5E,GAChCA,EAAUgF,oBAAoB,YAAa9D,EAAKiB,UAChDnC,EAAUgF,oBAAoB,aAAc9D,EAAKiB,UACjDnC,EAAUgF,oBAAoB,YAAa9D,EAAK6C,SAChD/D,EAAUgF,oBAAoB,YAAa9D,EAAK6C,SAChD/D,EAAUgF,oBAAoB,SAAU9D,EAAK6C,SAC7C/D,EAAUgF,oBAAoB,UAAW9D,EAAKuD,QAC9CzE,EAAUgF,oBAAoB,WAAY9D,EAAKuD,WAE1CvD,IAQR,CACDtC,IAAK,0BACLmG,MAAO,WACL,IAAI/E,EAAYiB,KAAKoB,cACjB4C,EAAiBhE,KAAKO,MAAMxB,UAC5BkF,EAAOlF,EAAUmF,wBAMrB,OAJAF,EAAe1B,EAAI2B,EAAKhB,KAAO3E,EAAO6F,YACtCH,EAAexB,EAAIyB,EAAKvD,IAAMpC,EAAO8F,YACrCJ,EAAezB,EAAI0B,EAAKf,MACxBc,EAAevB,EAAIwB,EAAKd,OACjBnD,OAQR,CACDrC,IAAK,wBACLmG,MAAO,SAA+B3C,GACpC,IAAIkD,EAAOlD,GAAKA,EAAEmD,SAAWnD,EAAEmD,QAAQ,IAAMnD,EACzCX,EAAUR,KAAKO,MAAMC,QAEzB,GAAI6D,GAA8B,iBAAfA,EAAKE,MAAoB,CAE1C,IAAIC,EAAM,CACRlC,EAAG+B,EAAKE,MACR/B,EAAG6B,EAAKI,OAGLjE,EAAQf,QAAOe,EAAQf,MAAQ+E,GAEpChE,EAAQC,IAAM+D,EAGhB,OAAOxE,OAQR,CACDrC,IAAK,sBACLmG,MAAO,WACL,IAAI1C,EAAgBpB,KAAKoB,cACrBZ,EAAUR,KAAKO,MAAMC,QACrBzB,EAAYiB,KAAKO,MAAMxB,UACvBE,EAAQe,KAAKO,MAAMtB,MAIlBA,EAAMQ,QAETR,EAAMQ,MAAQ,CACZ6C,EAAG9B,EAAQf,MAAM6C,EAAIvD,EAAUuD,EAAIlB,EAAciC,WACjDb,EAAGhC,EAAQf,MAAM+C,EAAIzD,EAAUyD,EAAIpB,EAAcgC,YAIrD,IAAIsB,EAAOlE,EAAQC,IAAI6B,EAAIvD,EAAUuD,EAAIlB,EAAciC,WACnDsB,EAAOnE,EAAQC,IAAI+B,EAAIzD,EAAUyD,EAAIpB,EAAcgC,UAWvD,OARAnE,EAAMyB,IAAM,CACV4B,EAAGsC,KAAKC,IAAI5F,EAAMQ,MAAM6C,EAAGoC,GAC3BlC,EAAGoC,KAAKC,IAAI5F,EAAMQ,MAAM+C,EAAGmC,IAE7B1F,EAAM0B,OAAS,CACb2B,EAAGsC,KAAKE,IAAI7F,EAAMQ,MAAM6C,EAAGoC,GAC3BlC,EAAGoC,KAAKE,IAAI7F,EAAMQ,MAAM+C,EAAGmC,IAEtB3E,OAQR,CACDrC,IAAK,UACLmG,MAAO,WACL,IAAI7D,EAAOD,KAEX,GAAIC,EAAKF,KAAKP,OAAQ,CACpB,IAAIuF,EAAY9E,EAAKF,KAAKf,QAAQE,SAC9B8F,EAAW/E,EAAKmB,cAAcd,iBAAiBL,EAAKF,KAAKP,QACzDkB,EAAMT,EAAKM,MAAMtB,MAAMyB,IACvBC,EAASV,EAAKM,MAAMtB,MAAM0B,OAC1BsE,EAAUhF,EAAKM,MAAMxB,UAAUuD,EAC/B4C,EAAUjF,EAAKM,MAAMxB,UAAUyD,EACnCvC,EAAKf,SAAW,GAChBwE,MAAM3F,UAAU4F,QAAQC,KAAKoB,GAAU,SAAUG,GAC/C,GAAIA,IAAYlF,EAAKhB,MAArB,CACA,IAEIgF,EAAOkB,EAAQjB,wBACfkB,EAAOnB,EAAKhB,KAAO3E,EAAO6F,YAAcc,EAAUhF,EAAKmB,cAAciC,WACrEgC,EAAOpB,EAAKvD,IAAMpC,EAAO8F,YAAcc,EAAUjF,EAAKmB,cAAcgC,UACpEkC,EAAUrB,EAAKf,MAAQkC,EACvBG,EAAUtB,EAAKd,OAASkC,GAEL,QAAnBpF,EAAKF,KAAKX,KAEFsB,EAAI4B,GAAK8C,GAAQ1E,EAAI8B,GAAK6C,GAAQ1E,EAAO2B,GAAKgD,GAAW3E,EAAO6B,GAAK+C,IAGnE7E,EAAI4B,EAAIgD,GAAW5E,EAAI8B,EAAI+C,GAAW5E,EAAO2B,EAAI8C,GAAQzE,EAAO6B,EAAI6C,KAIhFN,GAAaI,EAAQrE,UAAUC,IAAIgE,GACnC9E,EAAKf,SAASsG,KAAKL,IAEnBJ,GAAaI,EAAQrE,UAAU2E,OAAOV,OAK5C,OAAO9E,IAMR,CACDtC,IAAK,UACL+H,IAAK,WACH,MAAO,YAIJ9G,EA9UT,KAkVCN,OAAQC","file":"noose.es5.js","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (factory, window, document) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    // CommonJS\n    module.exports = factory(window, document);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(function () {\n      return factory(window, document);\n    });\n  } else {\n    window.Noose = factory(window, document);\n  }\n})(function (window, document) {\n  'use strict';\n\n  function noop() {} // Default options\n\n\n  var defaults = {\n    // Containing element for the noose\n    container: 'body',\n    // Classes for styling\n    classes: {\n      noose: '',\n      selected: 'selected'\n    },\n    // Whether the noose is enabled\n    enabled: true,\n    // The selection mode, part or whole\n    mode: 'touch',\n    // The amount of pixels to scroll\n    scroll: 10,\n    // The edge offset when scrolling should happen\n    scrollEdge: 10,\n    // The scrollbar size\n    scrollbar: 17,\n    // Elements to select\n    select: '*',\n    // On noose-ing start handler\n    start: noop,\n    // On noose-ing stop handler\n    stop: noop,\n    // Styles for the noose\n    style: {\n      border: '1px dotted #000',\n      zIndex: 1000\n    },\n    // Throttle calls to compute selection\n    throttle: 200\n  };\n\n  var Noose =\n  /*#__PURE__*/\n  function () {\n    function Noose(container, opts) {\n      _classCallCheck(this, Noose);\n\n      var self = this; // Parse arguments\n\n      if (_typeof(container) === 'object' && container != null && !(container instanceof Element)) {\n        opts = container;\n        container = null;\n      }\n\n      opts = self.opts = Object.assign({}, defaults, opts); // Container must be position (anything but static)\n\n      if (typeof container === 'string' || container instanceof Element) {\n        opts.container = container;\n      } // Get containers\n\n\n      if (opts.container instanceof Element) {\n        self.containers = [opts.container];\n      } else if (typeof opts.container === 'string') {\n        self.containers = document.querySelectorAll(opts.container);\n      } else {\n        throw new Error('Invalid container option');\n      } // Setup states\n\n\n      self.coors = {\n        // Relative to document top left origin\n        pointer: {\n          start: null,\n          end: null // The current/end position of the mouse/touch\n\n        },\n        // Relative to container\n        noose: {\n          top: null,\n          bottom: null // The bottom right position of the noose\n\n        },\n        // Relative to document top left origin\n        container: {}\n      }; // Create noose\n\n      var noose = self.noose = document.createElement('div');\n      noose.style.position = 'absolute';\n      noose.style.zIndex = self.opts.style.zIndex;\n      noose.style.border = self.opts.style.border;\n\n      if (opts.classes.noose) {\n        noose.classList.add(self.opts.classes.noose);\n      }\n\n      var started = false; // Flag for noose-ing started\n\n      var throttled = false;\n\n      self._onStart = function (e) {\n        if (self.opts.enabled && (!started || e.currentTarget !== self.currentTarget) && (e.type !== 'mousedown' || e.which === 1)) {\n          started = true;\n          self.currentTarget = e.currentTarget; // Initialize container values\n\n          var style = window.getComputedStyle(self.currentTarget);\n\n          if (style.position === 'static') {\n            console.warn('Container is not a positioned element. This may cause issues positioning the noose and/or selecting elements.');\n          }\n\n          var container = self.coors.container;\n          var pointer = self.coors.pointer;\n          var noose = self.coors.noose; // Does the container have scrollbars\n\n          if (self.opts.scroll > 0 && self.opts.scrollEdge > 0) {\n            container.scrollX = (style.overflowX === 'auto' || style.overflowX === 'scroll') && self.currentTarget.scrollHeight > self.currentTarget.clientHeight;\n            container.scrollY = (style.overflowY === 'auto' || style.overflowY === 'scroll') && self.currentTarget.scrollWidth > self.currentTarget.clientWidth;\n          } else {\n            container.scrollX = false;\n            container.scrollY = false;\n          } // Set the max allowed scroll amount\n\n\n          container.maxScrollY = container.scrollY && self.currentTarget.scrollHeight - self.currentTarget.clientHeight || 0;\n          container.maxScrollX = container.scrollX && self.currentTarget.scrollWidth - self.currentTarget.clientWidth || 0; // Reset start positions\n\n          pointer.start = null;\n          noose.start = null;\n          self.updateContainerPosition().updatePointerPosition(e); // If the scrollbar was click then don't start\n\n          if (self.opts.scrollbar && (container.scrollX && pointer.start.x > container.x + container.w - self.opts.scrollbar || container.scrollY && pointer.start.y > container.y + container.h - self.opts.scrollbar)) {\n            started = false;\n            return;\n          }\n\n          self.noose.style.display = 'none';\n\n          if (self.opts.start.apply(self, [e, self.coors]) === false || e.defaultPrevented) {\n            started = false;\n            return;\n          }\n\n          self.currentTarget.appendChild(self.noose);\n        }\n      };\n\n      self._onMove = function (e) {\n        if (self.opts.enabled) {\n          if (started && e.currentTarget === self.currentTarget) {\n            e.preventDefault();\n\n            if (e.type !== 'scroll') {\n              self.updatePointerPosition(e);\n            }\n\n            self.updateContainerPosition().updateNoosePosition(); // Draw noose\n\n            var top = self.coors.noose.top;\n            var bottom = self.coors.noose.bottom;\n            self.noose.style.left = top.x + 'px';\n            self.noose.style.top = top.y + 'px';\n            self.noose.style.width = bottom.x - top.x + 'px';\n            self.noose.style.height = bottom.y - top.y + 'px';\n            self.noose.style.display = 'block'; // Scroll container\n\n            var container = self.coors.container;\n            var pointer = self.coors.pointer.end;\n            if (container.scrollY && pointer.y - container.y < 10) self.currentTarget.scrollTop -= self.opts.scroll;else if (container.scrollY && self.currentTarget.scrollTop < container.maxScrollY && container.y + container.h - pointer.y < 10) self.currentTarget.scrollTop += self.opts.scroll;else if (container.scrollX && pointer.x - container.x < 10) self.currentTarget.scrollLeft -= self.opts.scroll;else if (container.scrollX && self.currentTarget.scrollLeft < container.maxScrollX && container.x + container.w - pointer.x < 10) self.currentTarget.scrollLeft += self.opts.scroll; // Compute selection\n\n            if (self.opts.throttle) {\n              // Throttle calls to compute\n              if (!throttled) {\n                throttled = true;\n                setTimeout(function () {\n                  self.compute();\n                  throttled = false;\n                }, self.opts.throttle);\n              }\n            } else {\n              self.compute();\n            }\n          }\n        }\n      };\n\n      self._onEnd = function (e) {\n        if (self.opts.enabled && started && (e.type !== 'mouseup' || e.which === 1)) {\n          started = false;\n\n          if (e.currentTarget === self.currentTarget) {\n            self.updateContainerPosition().updatePointerPosition(e).updateNoosePosition();\n            self.compute();\n            setTimeout(function () {\n              self.opts.stop.apply(self, [e, self.coors, self.selected]);\n            }, 0);\n            self.currentTarget.removeChild(self.noose);\n          }\n        }\n      }; // Register handlers\n\n\n      Array.prototype.forEach.call(self.containers, function (container) {\n        container.addEventListener('mousedown', self._onStart);\n        container.addEventListener('touchstart', self._onStart);\n        container.addEventListener('mousemove', self._onMove);\n        container.addEventListener('touchmove', self._onMove);\n        container.addEventListener('scroll', self._onMove);\n        container.addEventListener('mouseup', self._onEnd);\n        container.addEventListener('touchend', self._onEnd);\n      });\n      return self;\n    }\n    /**\n     * Destroy this Noose instance.\n     *\n     * @returns {Noose} This instance.\n     */\n\n\n    _createClass(Noose, [{\n      key: \"destroy\",\n      value: function destroy() {\n        var self = this;\n        self.containers.forEach(function (container) {\n          container.removeEventListener('mousedown', self._onStart);\n          container.removeEventListener('touchstart', self._onStart);\n          container.removeEventListener('mousemove', self._onMove);\n          container.removeEventListener('touchmove', self._onMove);\n          container.removeEventListener('scroll', self._onMove);\n          container.removeEventListener('mouseup', self._onEnd);\n          container.removeEventListener('touchend', self._onEnd);\n        });\n        return self;\n      }\n      /**\n       * Update the current container's position.\n       * \n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updateContainerPosition\",\n      value: function updateContainerPosition() {\n        var container = this.currentTarget;\n        var containerCoors = this.coors.container;\n        var rect = container.getBoundingClientRect(); // Get position relative to the document's top left origin\n\n        containerCoors.x = rect.left + window.pageXOffset;\n        containerCoors.y = rect.top + window.pageYOffset;\n        containerCoors.w = rect.width;\n        containerCoors.h = rect.height;\n        return this;\n      }\n      /**\n       * Update the current pointer (mouse/touch) position.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updatePointerPosition\",\n      value: function updatePointerPosition(e) {\n        var root = e && e.touches && e.touches[0] || e;\n        var pointer = this.coors.pointer;\n\n        if (root && typeof root.pageX === 'number') {\n          // Get position relative to the document's top left origin\n          var pos = {\n            x: root.pageX,\n            y: root.pageY\n          }; // Keep start static\n\n          if (!pointer.start) pointer.start = pos; // Current position is always end\n\n          pointer.end = pos;\n        }\n\n        return this;\n      }\n      /**\n       * Updates the noose top/bottom position.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"updateNoosePosition\",\n      value: function updateNoosePosition() {\n        var currentTarget = this.currentTarget;\n        var pointer = this.coors.pointer;\n        var container = this.coors.container;\n        var noose = this.coors.noose; // Pointer and container are both relative to document top left origin.\n        // The noose is positioned absolute relative to the container. So that's\n        // (pointer - container), and also account for the container's scroll position.\n\n        if (!noose.start) {\n          // Keep start position static\n          noose.start = {\n            x: pointer.start.x - container.x + currentTarget.scrollLeft,\n            y: pointer.start.y - container.y + currentTarget.scrollTop\n          };\n        }\n\n        var endX = pointer.end.x - container.x + currentTarget.scrollLeft;\n        var endY = pointer.end.y - container.y + currentTarget.scrollTop; // Determine top and bottom of the noose\n        // top < bottom\n\n        noose.top = {\n          x: Math.min(noose.start.x, endX),\n          y: Math.min(noose.start.y, endY)\n        };\n        noose.bottom = {\n          x: Math.max(noose.start.x, endX),\n          y: Math.max(noose.start.y, endY)\n        };\n        return this;\n      }\n      /**\n       * Compute the selected elements within the noose region.\n       *\n       * @returns {Noose} This instance.\n       */\n\n    }, {\n      key: \"compute\",\n      value: function compute() {\n        var self = this; // Only do if select is enabled\n\n        if (self.opts.select) {\n          var className = self.opts.classes.selected;\n          var elements = self.currentTarget.querySelectorAll(self.opts.select);\n          var top = self.coors.noose.top;\n          var bottom = self.coors.noose.bottom;\n          var offsetX = self.coors.container.x;\n          var offsetY = self.coors.container.y;\n          self.selected = [];\n          Array.prototype.forEach.call(elements, function (element) {\n            if (element === self.noose) return;\n            var include = false; // Get absolution position of element relative to container\n\n            var rect = element.getBoundingClientRect();\n            var topX = rect.left + window.pageXOffset - offsetX + self.currentTarget.scrollLeft;\n            var topY = rect.top + window.pageYOffset - offsetY + self.currentTarget.scrollTop;\n            var bottomX = rect.width + topX;\n            var bottomY = rect.height + topY;\n\n            if (self.opts.mode === 'fit') {\n              // Include is entire element is within noose\n              include = top.x <= topX && top.y <= topY && bottom.x >= bottomX && bottom.y >= bottomY;\n            } else {\n              // Include if partially touching\n              include = !(top.x > bottomX || top.y > bottomY || bottom.x < topX || bottom.y < topY);\n            }\n\n            if (include) {\n              className && element.classList.add(className);\n              self.selected.push(element);\n            } else {\n              className && element.classList.remove(className);\n            }\n          });\n        }\n\n        return self;\n      }\n      /**\n       * Get the current version.\n       */\n\n    }, {\n      key: \"version\",\n      get: function get() {\n        return '1.0.0';\n      }\n    }]);\n\n    return Noose;\n  }();\n\n  return Noose;\n}, window, document);"]}